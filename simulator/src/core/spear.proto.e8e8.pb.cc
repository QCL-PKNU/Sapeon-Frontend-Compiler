// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spear.proto.e8e8

#include "spear.proto.e8e8.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace sapeon {
namespace simulator {
PROTOBUF_CONSTEXPR SPLayer_SPConvolutionDesc::SPLayer_SPConvolutionDesc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.padding_)*/{}
  , /*decltype(_impl_.stride_)*/{}
  , /*decltype(_impl_.dilation_)*/{}
  , /*decltype(_impl_.dtype_)*/0
  , /*decltype(_impl_.groups_)*/0} {}
struct SPLayer_SPConvolutionDescDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayer_SPConvolutionDescDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayer_SPConvolutionDescDefaultTypeInternal() {}
  union {
    SPLayer_SPConvolutionDesc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayer_SPConvolutionDescDefaultTypeInternal _SPLayer_SPConvolutionDesc_default_instance_;
PROTOBUF_CONSTEXPR SPLayer_SPSamplingDesc::SPLayer_SPSamplingDesc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.padding_)*/{}
  , /*decltype(_impl_.stride_)*/{}
  , /*decltype(_impl_.window_)*/{}
  , /*decltype(_impl_.mode_)*/0} {}
struct SPLayer_SPSamplingDescDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayer_SPSamplingDescDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayer_SPSamplingDescDefaultTypeInternal() {}
  union {
    SPLayer_SPSamplingDesc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayer_SPSamplingDescDefaultTypeInternal _SPLayer_SPSamplingDesc_default_instance_;
PROTOBUF_CONSTEXPR SPLayer_SPEWAddDesc::SPLayer_SPEWAddDesc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.scale_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SPLayer_SPEWAddDescDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayer_SPEWAddDescDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayer_SPEWAddDescDefaultTypeInternal() {}
  union {
    SPLayer_SPEWAddDesc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayer_SPEWAddDescDefaultTypeInternal _SPLayer_SPEWAddDesc_default_instance_;
PROTOBUF_CONSTEXPR SPLayer_SPEWMulDesc::SPLayer_SPEWMulDesc(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_.scale_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}} {}
struct SPLayer_SPEWMulDescDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayer_SPEWMulDescDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayer_SPEWMulDescDefaultTypeInternal() {}
  union {
    SPLayer_SPEWMulDesc _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayer_SPEWMulDescDefaultTypeInternal _SPLayer_SPEWMulDesc_default_instance_;
PROTOBUF_CONSTEXPR SPLayer_SPTensor::SPLayer_SPTensor(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.dims_)*/{}
  , /*decltype(_impl_.fval_)*/{}
  , /*decltype(_impl_.bval_)*/{}
  , /*decltype(_impl_._bval_cached_byte_size_)*/{0}
  , /*decltype(_impl_.dtype_)*/0
  , /*decltype(_impl_.format_)*/0
  , /*decltype(_impl_.ptr_)*/int64_t{0}
  , /*decltype(_impl_.size_)*/0} {}
struct SPLayer_SPTensorDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayer_SPTensorDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayer_SPTensorDefaultTypeInternal() {}
  union {
    SPLayer_SPTensor _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayer_SPTensorDefaultTypeInternal _SPLayer_SPTensor_default_instance_;
PROTOBUF_CONSTEXPR SPLayer_Attribute::SPLayer_Attribute(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.floats_)*/{}
  , /*decltype(_impl_.ints_)*/{}
  , /*decltype(_impl_.strings_)*/{}
  , /*decltype(_impl_.s_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.i_)*/int64_t{0}
  , /*decltype(_impl_.f_)*/0
  , /*decltype(_impl_.type_)*/0} {}
struct SPLayer_AttributeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayer_AttributeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayer_AttributeDefaultTypeInternal() {}
  union {
    SPLayer_Attribute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayer_AttributeDefaultTypeInternal _SPLayer_Attribute_default_instance_;
PROTOBUF_CONSTEXPR SPLayer::SPLayer(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.type_)*/{}
  , /*decltype(_impl_.preds_)*/{}
  , /*decltype(_impl_.succs_)*/{}
  , /*decltype(_impl_.input_)*/{}
  , /*decltype(_impl_.input_threshold_)*/{}
  , /*decltype(_impl_.filter_threshold_)*/{}
  , /*decltype(_impl_.attributes_)*/{}
  , /*decltype(_impl_.name_)*/{&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}}
  , /*decltype(_impl_.output_)*/nullptr
  , /*decltype(_impl_.filter_)*/nullptr
  , /*decltype(_impl_.bias_)*/nullptr
  , /*decltype(_impl_.scale_)*/nullptr
  , /*decltype(_impl_.mean_)*/nullptr
  , /*decltype(_impl_.variance_)*/nullptr
  , /*decltype(_impl_.convdesc_)*/nullptr
  , /*decltype(_impl_.samplingdesc_)*/nullptr
  , /*decltype(_impl_.ewadddesc_)*/nullptr
  , /*decltype(_impl_.ewmuldesc_)*/nullptr
  , /*decltype(_impl_.id_)*/0
  , /*decltype(_impl_.output_threshold_)*/0
  , /*decltype(_impl_.epsilon_)*/0
  , /*decltype(_impl_.activation_)*/0} {}
struct SPLayerDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPLayerDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPLayerDefaultTypeInternal() {}
  union {
    SPLayer _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPLayerDefaultTypeInternal _SPLayer_default_instance_;
PROTOBUF_CONSTEXPR SPGraph::SPGraph(
    ::_pbi::ConstantInitialized): _impl_{
    /*decltype(_impl_._has_bits_)*/{}
  , /*decltype(_impl_._cached_size_)*/{}
  , /*decltype(_impl_.layer_)*/{}
  , /*decltype(_impl_.input_layers_)*/{}
  , /*decltype(_impl_.output_layers_)*/{}
  , /*decltype(_impl_.is_optimized_)*/false
  , /*decltype(_impl_.ir_version_)*/int64_t{2}} {}
struct SPGraphDefaultTypeInternal {
  PROTOBUF_CONSTEXPR SPGraphDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~SPGraphDefaultTypeInternal() {}
  union {
    SPGraph _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 SPGraphDefaultTypeInternal _SPGraph_default_instance_;
}  // namespace simulator
}  // namespace sapeon
static ::_pb::Metadata file_level_metadata_spear_2eproto_2ee8e8[8];
static const ::_pb::EnumDescriptor* file_level_enum_descriptors_spear_2eproto_2ee8e8[5];
static constexpr ::_pb::ServiceDescriptor const** file_level_service_descriptors_spear_2eproto_2ee8e8 = nullptr;

const uint32_t TableStruct_spear_2eproto_2ee8e8::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _impl_.dtype_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _impl_.padding_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _impl_.stride_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _impl_.dilation_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPConvolutionDesc, _impl_.groups_),
  0,
  ~0u,
  ~0u,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPSamplingDesc, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPSamplingDesc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPSamplingDesc, _impl_.mode_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPSamplingDesc, _impl_.padding_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPSamplingDesc, _impl_.stride_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPSamplingDesc, _impl_.window_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPEWAddDesc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPEWAddDesc, _impl_.scale_),
  ~0u,  // no _has_bits_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPEWMulDesc, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPEWMulDesc, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.dtype_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.format_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.dims_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.fval_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.bval_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.size_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_SPTensor, _impl_.ptr_),
  0,
  1,
  ~0u,
  ~0u,
  ~0u,
  3,
  2,
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.f_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.i_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.s_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.floats_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.ints_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer_Attribute, _impl_.strings_),
  1,
  4,
  3,
  2,
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.id_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.name_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.type_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.preds_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.succs_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.input_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.output_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.filter_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.bias_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.scale_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.mean_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.variance_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.epsilon_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.input_threshold_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.output_threshold_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.filter_threshold_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.convdesc_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.samplingdesc_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.ewadddesc_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.ewmuldesc_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.activation_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPLayer, _impl_.attributes_),
  11,
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  1,
  2,
  3,
  4,
  5,
  6,
  13,
  ~0u,
  12,
  ~0u,
  7,
  8,
  9,
  10,
  14,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _impl_._has_bits_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  ~0u,  // no _inlined_string_donated_
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _impl_.layer_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _impl_.input_layers_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _impl_.output_layers_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _impl_.ir_version_),
  PROTOBUF_FIELD_OFFSET(::sapeon::simulator::SPGraph, _impl_.is_optimized_),
  ~0u,
  ~0u,
  ~0u,
  1,
  0,
};
static const ::_pbi::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 11, -1, sizeof(::sapeon::simulator::SPLayer_SPConvolutionDesc)},
  { 16, 26, -1, sizeof(::sapeon::simulator::SPLayer_SPSamplingDesc)},
  { 30, -1, -1, sizeof(::sapeon::simulator::SPLayer_SPEWAddDesc)},
  { 37, -1, -1, sizeof(::sapeon::simulator::SPLayer_SPEWMulDesc)},
  { 44, 57, -1, sizeof(::sapeon::simulator::SPLayer_SPTensor)},
  { 64, 78, -1, sizeof(::sapeon::simulator::SPLayer_Attribute)},
  { 86, 114, -1, sizeof(::sapeon::simulator::SPLayer)},
  { 136, 147, -1, sizeof(::sapeon::simulator::SPGraph)},
};

static const ::_pb::Message* const file_default_instances[] = {
  &::sapeon::simulator::_SPLayer_SPConvolutionDesc_default_instance_._instance,
  &::sapeon::simulator::_SPLayer_SPSamplingDesc_default_instance_._instance,
  &::sapeon::simulator::_SPLayer_SPEWAddDesc_default_instance_._instance,
  &::sapeon::simulator::_SPLayer_SPEWMulDesc_default_instance_._instance,
  &::sapeon::simulator::_SPLayer_SPTensor_default_instance_._instance,
  &::sapeon::simulator::_SPLayer_Attribute_default_instance_._instance,
  &::sapeon::simulator::_SPLayer_default_instance_._instance,
  &::sapeon::simulator::_SPGraph_default_instance_._instance,
};

const char descriptor_table_protodef_spear_2eproto_2ee8e8[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\020spear.proto.e8e8\022\020sapeon.simulator\"\255\022\n"
  "\007SPLayer\022\n\n\002id\030\001 \002(\005\022\014\n\004name\030\002 \001(\t\022\014\n\004ty"
  "pe\030\003 \003(\t\022\r\n\005preds\030\004 \003(\005\022\r\n\005succs\030\005 \003(\005\0221"
  "\n\005input\030\006 \003(\0132\".sapeon.simulator.SPLayer"
  ".SPTensor\0222\n\006output\030\007 \001(\0132\".sapeon.simul"
  "ator.SPLayer.SPTensor\0222\n\006filter\030\010 \001(\0132\"."
  "sapeon.simulator.SPLayer.SPTensor\0220\n\004bia"
  "s\030\t \001(\0132\".sapeon.simulator.SPLayer.SPTen"
  "sor\0221\n\005scale\030\n \001(\0132\".sapeon.simulator.SP"
  "Layer.SPTensor\0220\n\004mean\030\013 \001(\0132\".sapeon.si"
  "mulator.SPLayer.SPTensor\0224\n\010variance\030\014 \001"
  "(\0132\".sapeon.simulator.SPLayer.SPTensor\022\017"
  "\n\007epsilon\030\020 \001(\002\022\027\n\017input_threshold\030\r \003(\002"
  "\022\030\n\020output_threshold\030\016 \001(\002\022\030\n\020filter_thr"
  "eshold\030\017 \003(\002\022=\n\010convdesc\030\024 \001(\0132+.sapeon."
  "simulator.SPLayer.SPConvolutionDesc\022>\n\014s"
  "amplingdesc\030\025 \001(\0132(.sapeon.simulator.SPL"
  "ayer.SPSamplingDesc\0228\n\tewadddesc\030\026 \001(\0132%"
  ".sapeon.simulator.SPLayer.SPEWAddDesc\0228\n"
  "\tewmuldesc\030\027 \001(\0132%.sapeon.simulator.SPLa"
  "yer.SPEWMulDesc\022>\n\nactivation\030\036 \001(\0162*.sa"
  "peon.simulator.SPLayer.SPActivationMode\022"
  "7\n\nattributes\030\037 \003(\0132#.sapeon.simulator.S"
  "PLayer.Attribute\032\213\001\n\021SPConvolutionDesc\0223"
  "\n\005dtype\030\001 \001(\0162$.sapeon.simulator.SPLayer"
  ".SPDataType\022\017\n\007padding\030\002 \003(\005\022\016\n\006stride\030\003"
  " \003(\005\022\020\n\010dilation\030\004 \003(\005\022\016\n\006groups\030\005 \002(\005\032y"
  "\n\016SPSamplingDesc\0226\n\004mode\030\001 \002(\0162(.sapeon."
  "simulator.SPLayer.SPSamplingMode\022\017\n\007padd"
  "ing\030\002 \003(\005\022\016\n\006stride\030\003 \003(\005\022\016\n\006window\030\004 \003("
  "\005\032\034\n\013SPEWAddDesc\022\r\n\005scale\030\001 \003(\002\032\034\n\013SPEWM"
  "ulDesc\022\r\n\005scale\030\001 \003(\002\032\302\001\n\010SPTensor\0223\n\005dt"
  "ype\030\001 \002(\0162$.sapeon.simulator.SPLayer.SPD"
  "ataType\0228\n\006format\030\002 \002(\0162(.sapeon.simulat"
  "or.SPLayer.SPTensorFormat\022\014\n\004dims\030\003 \003(\005\022"
  "\014\n\004fval\030\004 \003(\002\022\020\n\004bval\030\005 \003(\005B\002\020\001\022\014\n\004size\030"
  "\006 \001(\005\022\013\n\003ptr\030\007 \001(\003\032\215\002\n\tAttribute\022\014\n\004name"
  "\030\025 \001(\t\022\?\n\004type\030\024 \001(\01621.sapeon.simulator."
  "SPLayer.Attribute.AttributeType\022\t\n\001f\030\002 \001"
  "(\002\022\t\n\001i\030\003 \001(\003\022\t\n\001s\030\004 \001(\014\022\016\n\006floats\030\007 \003(\002"
  "\022\014\n\004ints\030\010 \003(\003\022\017\n\007strings\030\t \003(\014\"a\n\rAttri"
  "buteType\022\r\n\tUNDEFINED\020\000\022\t\n\005FLOAT\020\001\022\007\n\003IN"
  "T\020\002\022\n\n\006STRING\020\003\022\n\n\006FLOATS\020\006\022\010\n\004INTS\020\007\022\013\n"
  "\007STRINGS\020\010\"\372\001\n\020SPActivationMode\022\031\n\025SP_AC"
  "TIVATION_SIGMOID\020\000\022\026\n\022SP_ACTIVATION_RELU"
  "\020\001\022\034\n\030SP_ACTIVATION_LEAKY_RELU\020\002\022\027\n\023SP_A"
  "CTIVATION_PRELU\020\003\022\026\n\022SP_ACTIVATION_TANH\020"
  "\004\022\032\n\026SP_ACTIVATION_IDENTITY\020\005\022\026\n\022SP_ACTI"
  "VATION_MISH\020\006\022\027\n\023SP_ACTIVATION_RELU6\020\007\022\027"
  "\n\023SP_ACTIVATION_SWISH\020\010\"\255\001\n\016SPSamplingMo"
  "de\022\022\n\016SP_POOLING_MAX\020\000\022\035\n\031SP_POOLING_GLO"
  "BAL_AVERAGE\020\001\022\034\n\030SP_POOLING_LOCAL_AVERAG"
  "E\020\005\022\024\n\020SP_POOLING_REORG\020\002\022\027\n\023SP_POOLING_"
  "UPSAMPLE\020\003\022\033\n\027SP_POOLING_PIXELSHUFFLE\020\004\""
  "\177\n\nSPDataType\022\021\n\rSP_DATA_FLOAT\020\000\022\022\n\016SP_D"
  "ATA_DOUBLE\020\001\022\020\n\014SP_DATA_HALF\020\002\022\021\n\rSP_DAT"
  "A_UINT8\020\003\022\021\n\rSP_DATA_SINT8\020\004\022\022\n\016SP_DATA_"
  "SINT16\020\005\"b\n\016SPTensorFormat\022\022\n\016SP_FORMAT_"
  "NCHW\020\000\022\022\n\016SP_FORMAT_NHWC\020\001\022\022\n\016SP_FORMAT_"
  "NWHC\020\002\022\024\n\020SP_FORMAT_VECTOR\020\003\"\224\001\n\007SPGraph"
  "\022(\n\005layer\030\001 \003(\0132\031.sapeon.simulator.SPLay"
  "er\022\024\n\014input_layers\030\002 \003(\005\022\025\n\routput_layer"
  "s\030\003 \003(\005\022\025\n\nir_version\030\004 \001(\003:\0012\022\033\n\014is_opt"
  "imized\030\005 \001(\010:\005false"
  ;
static ::_pbi::once_flag descriptor_table_spear_2eproto_2ee8e8_once;
const ::_pbi::DescriptorTable descriptor_table_spear_2eproto_2ee8e8 = {
    false, false, 2539, descriptor_table_protodef_spear_2eproto_2ee8e8,
    "spear.proto.e8e8",
    &descriptor_table_spear_2eproto_2ee8e8_once, nullptr, 0, 8,
    schemas, file_default_instances, TableStruct_spear_2eproto_2ee8e8::offsets,
    file_level_metadata_spear_2eproto_2ee8e8, file_level_enum_descriptors_spear_2eproto_2ee8e8,
    file_level_service_descriptors_spear_2eproto_2ee8e8,
};
PROTOBUF_ATTRIBUTE_WEAK const ::_pbi::DescriptorTable* descriptor_table_spear_2eproto_2ee8e8_getter() {
  return &descriptor_table_spear_2eproto_2ee8e8;
}

// Force running AddDescriptors() at dynamic initialization time.
PROTOBUF_ATTRIBUTE_INIT_PRIORITY2 static ::_pbi::AddDescriptorsRunner dynamic_init_dummy_spear_2eproto_2ee8e8(&descriptor_table_spear_2eproto_2ee8e8);
namespace sapeon {
namespace simulator {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_Attribute_AttributeType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spear_2eproto_2ee8e8);
  return file_level_enum_descriptors_spear_2eproto_2ee8e8[0];
}
bool SPLayer_Attribute_AttributeType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::UNDEFINED;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::FLOAT;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::INT;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::STRING;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::FLOATS;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::INTS;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::STRINGS;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::AttributeType_MIN;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute::AttributeType_MAX;
constexpr int SPLayer_Attribute::AttributeType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPActivationMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spear_2eproto_2ee8e8);
  return file_level_enum_descriptors_spear_2eproto_2ee8e8[1];
}
bool SPLayer_SPActivationMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_SIGMOID;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_RELU;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_LEAKY_RELU;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_PRELU;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_TANH;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_IDENTITY;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_MISH;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_RELU6;
constexpr SPLayer_SPActivationMode SPLayer::SP_ACTIVATION_SWISH;
constexpr SPLayer_SPActivationMode SPLayer::SPActivationMode_MIN;
constexpr SPLayer_SPActivationMode SPLayer::SPActivationMode_MAX;
constexpr int SPLayer::SPActivationMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPSamplingMode_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spear_2eproto_2ee8e8);
  return file_level_enum_descriptors_spear_2eproto_2ee8e8[2];
}
bool SPLayer_SPSamplingMode_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SPLayer_SPSamplingMode SPLayer::SP_POOLING_MAX;
constexpr SPLayer_SPSamplingMode SPLayer::SP_POOLING_GLOBAL_AVERAGE;
constexpr SPLayer_SPSamplingMode SPLayer::SP_POOLING_LOCAL_AVERAGE;
constexpr SPLayer_SPSamplingMode SPLayer::SP_POOLING_REORG;
constexpr SPLayer_SPSamplingMode SPLayer::SP_POOLING_UPSAMPLE;
constexpr SPLayer_SPSamplingMode SPLayer::SP_POOLING_PIXELSHUFFLE;
constexpr SPLayer_SPSamplingMode SPLayer::SPSamplingMode_MIN;
constexpr SPLayer_SPSamplingMode SPLayer::SPSamplingMode_MAX;
constexpr int SPLayer::SPSamplingMode_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPDataType_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spear_2eproto_2ee8e8);
  return file_level_enum_descriptors_spear_2eproto_2ee8e8[3];
}
bool SPLayer_SPDataType_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SPLayer_SPDataType SPLayer::SP_DATA_FLOAT;
constexpr SPLayer_SPDataType SPLayer::SP_DATA_DOUBLE;
constexpr SPLayer_SPDataType SPLayer::SP_DATA_HALF;
constexpr SPLayer_SPDataType SPLayer::SP_DATA_UINT8;
constexpr SPLayer_SPDataType SPLayer::SP_DATA_SINT8;
constexpr SPLayer_SPDataType SPLayer::SP_DATA_SINT16;
constexpr SPLayer_SPDataType SPLayer::SPDataType_MIN;
constexpr SPLayer_SPDataType SPLayer::SPDataType_MAX;
constexpr int SPLayer::SPDataType_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPTensorFormat_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_spear_2eproto_2ee8e8);
  return file_level_enum_descriptors_spear_2eproto_2ee8e8[4];
}
bool SPLayer_SPTensorFormat_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr SPLayer_SPTensorFormat SPLayer::SP_FORMAT_NCHW;
constexpr SPLayer_SPTensorFormat SPLayer::SP_FORMAT_NHWC;
constexpr SPLayer_SPTensorFormat SPLayer::SP_FORMAT_NWHC;
constexpr SPLayer_SPTensorFormat SPLayer::SP_FORMAT_VECTOR;
constexpr SPLayer_SPTensorFormat SPLayer::SPTensorFormat_MIN;
constexpr SPLayer_SPTensorFormat SPLayer::SPTensorFormat_MAX;
constexpr int SPLayer::SPTensorFormat_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class SPLayer_SPConvolutionDesc::_Internal {
 public:
  using HasBits = decltype(std::declval<SPLayer_SPConvolutionDesc>()._impl_._has_bits_);
  static void set_has_dtype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_groups(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000002) ^ 0x00000002) != 0;
  }
};

SPLayer_SPConvolutionDesc::SPLayer_SPConvolutionDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer.SPConvolutionDesc)
}
SPLayer_SPConvolutionDesc::SPLayer_SPConvolutionDesc(const SPLayer_SPConvolutionDesc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer_SPConvolutionDesc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.padding_){from._impl_.padding_}
    , decltype(_impl_.stride_){from._impl_.stride_}
    , decltype(_impl_.dilation_){from._impl_.dilation_}
    , decltype(_impl_.dtype_){}
    , decltype(_impl_.groups_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dtype_, &from._impl_.dtype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.groups_) -
    reinterpret_cast<char*>(&_impl_.dtype_)) + sizeof(_impl_.groups_));
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer.SPConvolutionDesc)
}

inline void SPLayer_SPConvolutionDesc::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.padding_){arena}
    , decltype(_impl_.stride_){arena}
    , decltype(_impl_.dilation_){arena}
    , decltype(_impl_.dtype_){0}
    , decltype(_impl_.groups_){0}
  };
}

SPLayer_SPConvolutionDesc::~SPLayer_SPConvolutionDesc() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer.SPConvolutionDesc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer_SPConvolutionDesc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.padding_.~RepeatedField();
  _impl_.stride_.~RepeatedField();
  _impl_.dilation_.~RepeatedField();
}

void SPLayer_SPConvolutionDesc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer_SPConvolutionDesc::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer.SPConvolutionDesc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.padding_.Clear();
  _impl_.stride_.Clear();
  _impl_.dilation_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&_impl_.dtype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.groups_) -
        reinterpret_cast<char*>(&_impl_.dtype_)) + sizeof(_impl_.groups_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer_SPConvolutionDesc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional .sapeon.simulator.SPLayer.SPDataType dtype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sapeon::simulator::SPLayer_SPDataType_IsValid(val))) {
            _internal_set_dtype(static_cast<::sapeon::simulator::SPLayer_SPDataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int32 padding = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_padding(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_padding(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 stride = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_stride(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_stride(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 dilation = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dilation(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_dilation(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // required int32 groups = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_groups(&has_bits);
          _impl_.groups_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer_SPConvolutionDesc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer.SPConvolutionDesc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional .sapeon.simulator.SPLayer.SPDataType dtype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dtype(), target);
  }

  // repeated int32 padding = 2;
  for (int i = 0, n = this->_internal_padding_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_padding(i), target);
  }

  // repeated int32 stride = 3;
  for (int i = 0, n = this->_internal_stride_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_stride(i), target);
  }

  // repeated int32 dilation = 4;
  for (int i = 0, n = this->_internal_dilation_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_dilation(i), target);
  }

  // required int32 groups = 5;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_groups(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer.SPConvolutionDesc)
  return target;
}

size_t SPLayer_SPConvolutionDesc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer.SPConvolutionDesc)
  size_t total_size = 0;

  // required int32 groups = 5;
  if (_internal_has_groups()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_groups());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 padding = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.padding_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_padding_size());
    total_size += data_size;
  }

  // repeated int32 stride = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.stride_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_stride_size());
    total_size += data_size;
  }

  // repeated int32 dilation = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.dilation_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dilation_size());
    total_size += data_size;
  }

  // optional .sapeon.simulator.SPLayer.SPDataType dtype = 1;
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dtype());
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer_SPConvolutionDesc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer_SPConvolutionDesc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer_SPConvolutionDesc::GetClassData() const { return &_class_data_; }


void SPLayer_SPConvolutionDesc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer_SPConvolutionDesc*>(&to_msg);
  auto& from = static_cast<const SPLayer_SPConvolutionDesc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer.SPConvolutionDesc)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.padding_.MergeFrom(from._impl_.padding_);
  _this->_impl_.stride_.MergeFrom(from._impl_.stride_);
  _this->_impl_.dilation_.MergeFrom(from._impl_.dilation_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dtype_ = from._impl_.dtype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.groups_ = from._impl_.groups_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer_SPConvolutionDesc::CopyFrom(const SPLayer_SPConvolutionDesc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer.SPConvolutionDesc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer_SPConvolutionDesc::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SPLayer_SPConvolutionDesc::InternalSwap(SPLayer_SPConvolutionDesc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.padding_.InternalSwap(&other->_impl_.padding_);
  _impl_.stride_.InternalSwap(&other->_impl_.stride_);
  _impl_.dilation_.InternalSwap(&other->_impl_.dilation_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SPLayer_SPConvolutionDesc, _impl_.groups_)
      + sizeof(SPLayer_SPConvolutionDesc::_impl_.groups_)
      - PROTOBUF_FIELD_OFFSET(SPLayer_SPConvolutionDesc, _impl_.dtype_)>(
          reinterpret_cast<char*>(&_impl_.dtype_),
          reinterpret_cast<char*>(&other->_impl_.dtype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer_SPConvolutionDesc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[0]);
}

// ===================================================================

class SPLayer_SPSamplingDesc::_Internal {
 public:
  using HasBits = decltype(std::declval<SPLayer_SPSamplingDesc>()._impl_._has_bits_);
  static void set_has_mode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000001) ^ 0x00000001) != 0;
  }
};

SPLayer_SPSamplingDesc::SPLayer_SPSamplingDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer.SPSamplingDesc)
}
SPLayer_SPSamplingDesc::SPLayer_SPSamplingDesc(const SPLayer_SPSamplingDesc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer_SPSamplingDesc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.padding_){from._impl_.padding_}
    , decltype(_impl_.stride_){from._impl_.stride_}
    , decltype(_impl_.window_){from._impl_.window_}
    , decltype(_impl_.mode_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _this->_impl_.mode_ = from._impl_.mode_;
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer.SPSamplingDesc)
}

inline void SPLayer_SPSamplingDesc::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.padding_){arena}
    , decltype(_impl_.stride_){arena}
    , decltype(_impl_.window_){arena}
    , decltype(_impl_.mode_){0}
  };
}

SPLayer_SPSamplingDesc::~SPLayer_SPSamplingDesc() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer.SPSamplingDesc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer_SPSamplingDesc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.padding_.~RepeatedField();
  _impl_.stride_.~RepeatedField();
  _impl_.window_.~RepeatedField();
}

void SPLayer_SPSamplingDesc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer_SPSamplingDesc::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer.SPSamplingDesc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.padding_.Clear();
  _impl_.stride_.Clear();
  _impl_.window_.Clear();
  _impl_.mode_ = 0;
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer_SPSamplingDesc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .sapeon.simulator.SPLayer.SPSamplingMode mode = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sapeon::simulator::SPLayer_SPSamplingMode_IsValid(val))) {
            _internal_set_mode(static_cast<::sapeon::simulator::SPLayer_SPSamplingMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int32 padding = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_padding(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_padding(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 stride = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_stride(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_stride(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 window = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_window(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_window(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer_SPSamplingDesc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer.SPSamplingDesc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .sapeon.simulator.SPLayer.SPSamplingMode mode = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_mode(), target);
  }

  // repeated int32 padding = 2;
  for (int i = 0, n = this->_internal_padding_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_padding(i), target);
  }

  // repeated int32 stride = 3;
  for (int i = 0, n = this->_internal_stride_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_stride(i), target);
  }

  // repeated int32 window = 4;
  for (int i = 0, n = this->_internal_window_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_window(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer.SPSamplingDesc)
  return target;
}

size_t SPLayer_SPSamplingDesc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer.SPSamplingDesc)
  size_t total_size = 0;

  // required .sapeon.simulator.SPLayer.SPSamplingMode mode = 1;
  if (_internal_has_mode()) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_mode());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 padding = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.padding_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_padding_size());
    total_size += data_size;
  }

  // repeated int32 stride = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.stride_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_stride_size());
    total_size += data_size;
  }

  // repeated int32 window = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.window_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_window_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer_SPSamplingDesc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer_SPSamplingDesc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer_SPSamplingDesc::GetClassData() const { return &_class_data_; }


void SPLayer_SPSamplingDesc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer_SPSamplingDesc*>(&to_msg);
  auto& from = static_cast<const SPLayer_SPSamplingDesc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer.SPSamplingDesc)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.padding_.MergeFrom(from._impl_.padding_);
  _this->_impl_.stride_.MergeFrom(from._impl_.stride_);
  _this->_impl_.window_.MergeFrom(from._impl_.window_);
  if (from._internal_has_mode()) {
    _this->_internal_set_mode(from._internal_mode());
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer_SPSamplingDesc::CopyFrom(const SPLayer_SPSamplingDesc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer.SPSamplingDesc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer_SPSamplingDesc::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SPLayer_SPSamplingDesc::InternalSwap(SPLayer_SPSamplingDesc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.padding_.InternalSwap(&other->_impl_.padding_);
  _impl_.stride_.InternalSwap(&other->_impl_.stride_);
  _impl_.window_.InternalSwap(&other->_impl_.window_);
  swap(_impl_.mode_, other->_impl_.mode_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer_SPSamplingDesc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[1]);
}

// ===================================================================

class SPLayer_SPEWAddDesc::_Internal {
 public:
};

SPLayer_SPEWAddDesc::SPLayer_SPEWAddDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer.SPEWAddDesc)
}
SPLayer_SPEWAddDesc::SPLayer_SPEWAddDesc(const SPLayer_SPEWAddDesc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer_SPEWAddDesc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.scale_){from._impl_.scale_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer.SPEWAddDesc)
}

inline void SPLayer_SPEWAddDesc::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.scale_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SPLayer_SPEWAddDesc::~SPLayer_SPEWAddDesc() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer.SPEWAddDesc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer_SPEWAddDesc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.scale_.~RepeatedField();
}

void SPLayer_SPEWAddDesc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer_SPEWAddDesc::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer.SPEWAddDesc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.scale_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer_SPEWAddDesc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float scale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_scale(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer_SPEWAddDesc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer.SPEWAddDesc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float scale = 1;
  for (int i = 0, n = this->_internal_scale_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_scale(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer.SPEWAddDesc)
  return target;
}

size_t SPLayer_SPEWAddDesc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer.SPEWAddDesc)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float scale = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_scale_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_scale_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer_SPEWAddDesc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer_SPEWAddDesc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer_SPEWAddDesc::GetClassData() const { return &_class_data_; }


void SPLayer_SPEWAddDesc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer_SPEWAddDesc*>(&to_msg);
  auto& from = static_cast<const SPLayer_SPEWAddDesc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer.SPEWAddDesc)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.scale_.MergeFrom(from._impl_.scale_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer_SPEWAddDesc::CopyFrom(const SPLayer_SPEWAddDesc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer.SPEWAddDesc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer_SPEWAddDesc::IsInitialized() const {
  return true;
}

void SPLayer_SPEWAddDesc::InternalSwap(SPLayer_SPEWAddDesc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.scale_.InternalSwap(&other->_impl_.scale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer_SPEWAddDesc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[2]);
}

// ===================================================================

class SPLayer_SPEWMulDesc::_Internal {
 public:
};

SPLayer_SPEWMulDesc::SPLayer_SPEWMulDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer.SPEWMulDesc)
}
SPLayer_SPEWMulDesc::SPLayer_SPEWMulDesc(const SPLayer_SPEWMulDesc& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer_SPEWMulDesc* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_.scale_){from._impl_.scale_}
    , /*decltype(_impl_._cached_size_)*/{}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer.SPEWMulDesc)
}

inline void SPLayer_SPEWMulDesc::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_.scale_){arena}
    , /*decltype(_impl_._cached_size_)*/{}
  };
}

SPLayer_SPEWMulDesc::~SPLayer_SPEWMulDesc() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer.SPEWMulDesc)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer_SPEWMulDesc::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.scale_.~RepeatedField();
}

void SPLayer_SPEWMulDesc::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer_SPEWMulDesc::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer.SPEWMulDesc)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.scale_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer_SPEWMulDesc::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated float scale = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 13)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_scale(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<13>(ptr));
        } else if (static_cast<uint8_t>(tag) == 10) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_scale(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer_SPEWMulDesc::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer.SPEWMulDesc)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated float scale = 1;
  for (int i = 0, n = this->_internal_scale_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(1, this->_internal_scale(i), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer.SPEWMulDesc)
  return target;
}

size_t SPLayer_SPEWMulDesc::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer.SPEWMulDesc)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float scale = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_scale_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_scale_size());
    total_size += data_size;
  }

  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer_SPEWMulDesc::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer_SPEWMulDesc::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer_SPEWMulDesc::GetClassData() const { return &_class_data_; }


void SPLayer_SPEWMulDesc::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer_SPEWMulDesc*>(&to_msg);
  auto& from = static_cast<const SPLayer_SPEWMulDesc&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer.SPEWMulDesc)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.scale_.MergeFrom(from._impl_.scale_);
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer_SPEWMulDesc::CopyFrom(const SPLayer_SPEWMulDesc& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer.SPEWMulDesc)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer_SPEWMulDesc::IsInitialized() const {
  return true;
}

void SPLayer_SPEWMulDesc::InternalSwap(SPLayer_SPEWMulDesc* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  _impl_.scale_.InternalSwap(&other->_impl_.scale_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer_SPEWMulDesc::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[3]);
}

// ===================================================================

class SPLayer_SPTensor::_Internal {
 public:
  using HasBits = decltype(std::declval<SPLayer_SPTensor>()._impl_._has_bits_);
  static void set_has_dtype(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_format(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_ptr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000003) ^ 0x00000003) != 0;
  }
};

SPLayer_SPTensor::SPLayer_SPTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer.SPTensor)
}
SPLayer_SPTensor::SPLayer_SPTensor(const SPLayer_SPTensor& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer_SPTensor* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dims_){from._impl_.dims_}
    , decltype(_impl_.fval_){from._impl_.fval_}
    , decltype(_impl_.bval_){from._impl_.bval_}
    , /*decltype(_impl_._bval_cached_byte_size_)*/{0}
    , decltype(_impl_.dtype_){}
    , decltype(_impl_.format_){}
    , decltype(_impl_.ptr_){}
    , decltype(_impl_.size_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.dtype_, &from._impl_.dtype_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.size_) -
    reinterpret_cast<char*>(&_impl_.dtype_)) + sizeof(_impl_.size_));
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer.SPTensor)
}

inline void SPLayer_SPTensor::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.dims_){arena}
    , decltype(_impl_.fval_){arena}
    , decltype(_impl_.bval_){arena}
    , /*decltype(_impl_._bval_cached_byte_size_)*/{0}
    , decltype(_impl_.dtype_){0}
    , decltype(_impl_.format_){0}
    , decltype(_impl_.ptr_){int64_t{0}}
    , decltype(_impl_.size_){0}
  };
}

SPLayer_SPTensor::~SPLayer_SPTensor() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer.SPTensor)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer_SPTensor::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.dims_.~RepeatedField();
  _impl_.fval_.~RepeatedField();
  _impl_.bval_.~RepeatedField();
}

void SPLayer_SPTensor::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer_SPTensor::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer.SPTensor)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.dims_.Clear();
  _impl_.fval_.Clear();
  _impl_.bval_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    ::memset(&_impl_.dtype_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.size_) -
        reinterpret_cast<char*>(&_impl_.dtype_)) + sizeof(_impl_.size_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer_SPTensor::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required .sapeon.simulator.SPLayer.SPDataType dtype = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sapeon::simulator::SPLayer_SPDataType_IsValid(val))) {
            _internal_set_dtype(static_cast<::sapeon::simulator::SPLayer_SPDataType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // required .sapeon.simulator.SPLayer.SPTensorFormat format = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sapeon::simulator::SPLayer_SPTensorFormat_IsValid(val))) {
            _internal_set_format(static_cast<::sapeon::simulator::SPLayer_SPTensorFormat>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated int32 dims = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_dims(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_dims(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float fval = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 37)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_fval(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<37>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_fval(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 bval = 5 [packed = true];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_bval(), ptr, ctx);
          CHK_(ptr);
        } else if (static_cast<uint8_t>(tag) == 40) {
          _internal_add_bval(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int32 size = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 48)) {
          _Internal::set_has_size(&has_bits);
          _impl_.size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ptr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 56)) {
          _Internal::set_has_ptr(&has_bits);
          _impl_.ptr_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer_SPTensor::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer.SPTensor)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required .sapeon.simulator.SPLayer.SPDataType dtype = 1;
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_dtype(), target);
  }

  // required .sapeon.simulator.SPLayer.SPTensorFormat format = 2;
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      2, this->_internal_format(), target);
  }

  // repeated int32 dims = 3;
  for (int i = 0, n = this->_internal_dims_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_dims(i), target);
  }

  // repeated float fval = 4;
  for (int i = 0, n = this->_internal_fval_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(4, this->_internal_fval(i), target);
  }

  // repeated int32 bval = 5 [packed = true];
  {
    int byte_size = _impl_._bval_cached_byte_size_.load(std::memory_order_relaxed);
    if (byte_size > 0) {
      target = stream->WriteInt32Packed(
          5, _internal_bval(), byte_size, target);
    }
  }

  // optional int32 size = 6;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(6, this->_internal_size(), target);
  }

  // optional int64 ptr = 7;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(7, this->_internal_ptr(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer.SPTensor)
  return target;
}

size_t SPLayer_SPTensor::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:sapeon.simulator.SPLayer.SPTensor)
  size_t total_size = 0;

  if (_internal_has_dtype()) {
    // required .sapeon.simulator.SPLayer.SPDataType dtype = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dtype());
  }

  if (_internal_has_format()) {
    // required .sapeon.simulator.SPLayer.SPTensorFormat format = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_format());
  }

  return total_size;
}
size_t SPLayer_SPTensor::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer.SPTensor)
  size_t total_size = 0;

  if (((_impl_._has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .sapeon.simulator.SPLayer.SPDataType dtype = 1;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_dtype());

    // required .sapeon.simulator.SPLayer.SPTensorFormat format = 2;
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_format());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated int32 dims = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.dims_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_dims_size());
    total_size += data_size;
  }

  // repeated float fval = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_fval_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_fval_size());
    total_size += data_size;
  }

  // repeated int32 bval = 5 [packed = true];
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.bval_);
    if (data_size > 0) {
      total_size += 1 +
        ::_pbi::WireFormatLite::Int32Size(static_cast<int32_t>(data_size));
    }
    int cached_size = ::_pbi::ToCachedSize(data_size);
    _impl_._bval_cached_byte_size_.store(cached_size,
                                    std::memory_order_relaxed);
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000cu) {
    // optional int64 ptr = 7;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ptr());
    }

    // optional int32 size = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_size());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer_SPTensor::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer_SPTensor::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer_SPTensor::GetClassData() const { return &_class_data_; }


void SPLayer_SPTensor::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer_SPTensor*>(&to_msg);
  auto& from = static_cast<const SPLayer_SPTensor&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer.SPTensor)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.dims_.MergeFrom(from._impl_.dims_);
  _this->_impl_.fval_.MergeFrom(from._impl_.fval_);
  _this->_impl_.bval_.MergeFrom(from._impl_.bval_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.dtype_ = from._impl_.dtype_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.format_ = from._impl_.format_;
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.ptr_ = from._impl_.ptr_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.size_ = from._impl_.size_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer_SPTensor::CopyFrom(const SPLayer_SPTensor& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer.SPTensor)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer_SPTensor::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  return true;
}

void SPLayer_SPTensor::InternalSwap(SPLayer_SPTensor* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.dims_.InternalSwap(&other->_impl_.dims_);
  _impl_.fval_.InternalSwap(&other->_impl_.fval_);
  _impl_.bval_.InternalSwap(&other->_impl_.bval_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SPLayer_SPTensor, _impl_.size_)
      + sizeof(SPLayer_SPTensor::_impl_.size_)
      - PROTOBUF_FIELD_OFFSET(SPLayer_SPTensor, _impl_.dtype_)>(
          reinterpret_cast<char*>(&_impl_.dtype_),
          reinterpret_cast<char*>(&other->_impl_.dtype_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer_SPTensor::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[4]);
}

// ===================================================================

class SPLayer_Attribute::_Internal {
 public:
  using HasBits = decltype(std::declval<SPLayer_Attribute>()._impl_._has_bits_);
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_type(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_f(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_i(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_s(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SPLayer_Attribute::SPLayer_Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer.Attribute)
}
SPLayer_Attribute::SPLayer_Attribute(const SPLayer_Attribute& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer_Attribute* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.floats_){from._impl_.floats_}
    , decltype(_impl_.ints_){from._impl_.ints_}
    , decltype(_impl_.strings_){from._impl_.strings_}
    , decltype(_impl_.s_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.i_){}
    , decltype(_impl_.f_){}
    , decltype(_impl_.type_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.s_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.s_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_s()) {
    _this->_impl_.s_.Set(from._internal_s(), 
      _this->GetArenaForAllocation());
  }
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  ::memcpy(&_impl_.i_, &from._impl_.i_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.type_) -
    reinterpret_cast<char*>(&_impl_.i_)) + sizeof(_impl_.type_));
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer.Attribute)
}

inline void SPLayer_Attribute::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.floats_){arena}
    , decltype(_impl_.ints_){arena}
    , decltype(_impl_.strings_){arena}
    , decltype(_impl_.s_){}
    , decltype(_impl_.name_){}
    , decltype(_impl_.i_){int64_t{0}}
    , decltype(_impl_.f_){0}
    , decltype(_impl_.type_){0}
  };
  _impl_.s_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.s_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SPLayer_Attribute::~SPLayer_Attribute() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer.Attribute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer_Attribute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.floats_.~RepeatedField();
  _impl_.ints_.~RepeatedField();
  _impl_.strings_.~RepeatedPtrField();
  _impl_.s_.Destroy();
  _impl_.name_.Destroy();
}

void SPLayer_Attribute::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer_Attribute::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer.Attribute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.floats_.Clear();
  _impl_.ints_.Clear();
  _impl_.strings_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.s_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
  }
  if (cached_has_bits & 0x0000001cu) {
    ::memset(&_impl_.i_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.type_) -
        reinterpret_cast<char*>(&_impl_.i_)) + sizeof(_impl_.type_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer_Attribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // optional float f = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 21)) {
          _Internal::set_has_f(&has_bits);
          _impl_.f_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional int64 i = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          _Internal::set_has_i(&has_bits);
          _impl_.i_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bytes s = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          auto str = _internal_mutable_s();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float floats = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 61)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_floats(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<61>(ptr));
        } else if (static_cast<uint8_t>(tag) == 58) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_floats(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int64 ints = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 64)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_ints(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<64>(ptr));
        } else if (static_cast<uint8_t>(tag) == 66) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt64Parser(_internal_mutable_ints(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated bytes strings = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_strings();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<74>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.Attribute.AttributeType type = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 160)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sapeon::simulator::SPLayer_Attribute_AttributeType_IsValid(val))) {
            _internal_set_type(static_cast<::sapeon::simulator::SPLayer_Attribute_AttributeType>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(20, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // optional string name = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "sapeon.simulator.SPLayer.Attribute.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer_Attribute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer.Attribute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // optional float f = 2;
  if (cached_has_bits & 0x00000008u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(2, this->_internal_f(), target);
  }

  // optional int64 i = 3;
  if (cached_has_bits & 0x00000004u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(3, this->_internal_i(), target);
  }

  // optional bytes s = 4;
  if (cached_has_bits & 0x00000001u) {
    target = stream->WriteBytesMaybeAliased(
        4, this->_internal_s(), target);
  }

  // repeated float floats = 7;
  for (int i = 0, n = this->_internal_floats_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(7, this->_internal_floats(i), target);
  }

  // repeated int64 ints = 8;
  for (int i = 0, n = this->_internal_ints_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(8, this->_internal_ints(i), target);
  }

  // repeated bytes strings = 9;
  for (int i = 0, n = this->_internal_strings_size(); i < n; i++) {
    const auto& s = this->_internal_strings(i);
    target = stream->WriteBytes(9, s, target);
  }

  // optional .sapeon.simulator.SPLayer.Attribute.AttributeType type = 20;
  if (cached_has_bits & 0x00000010u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      20, this->_internal_type(), target);
  }

  // optional string name = 21;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sapeon.simulator.SPLayer.Attribute.name");
    target = stream->WriteStringMaybeAliased(
        21, this->_internal_name(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer.Attribute)
  return target;
}

size_t SPLayer_Attribute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer.Attribute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated float floats = 7;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_floats_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_floats_size());
    total_size += data_size;
  }

  // repeated int64 ints = 8;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int64Size(this->_impl_.ints_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_ints_size());
    total_size += data_size;
  }

  // repeated bytes strings = 9;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.strings_.size());
  for (int i = 0, n = _impl_.strings_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
      _impl_.strings_.Get(i));
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional bytes s = 4;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
          this->_internal_s());
    }

    // optional string name = 21;
    if (cached_has_bits & 0x00000002u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional int64 i = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_i());
    }

    // optional float f = 2;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 + 4;
    }

    // optional .sapeon.simulator.SPLayer.Attribute.AttributeType type = 20;
    if (cached_has_bits & 0x00000010u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer_Attribute::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer_Attribute::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer_Attribute::GetClassData() const { return &_class_data_; }


void SPLayer_Attribute::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer_Attribute*>(&to_msg);
  auto& from = static_cast<const SPLayer_Attribute&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer.Attribute)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.floats_.MergeFrom(from._impl_.floats_);
  _this->_impl_.ints_.MergeFrom(from._impl_.ints_);
  _this->_impl_.strings_.MergeFrom(from._impl_.strings_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_s(from._internal_s());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_impl_.i_ = from._impl_.i_;
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_impl_.f_ = from._impl_.f_;
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_impl_.type_ = from._impl_.type_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer_Attribute::CopyFrom(const SPLayer_Attribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer.Attribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer_Attribute::IsInitialized() const {
  return true;
}

void SPLayer_Attribute::InternalSwap(SPLayer_Attribute* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.floats_.InternalSwap(&other->_impl_.floats_);
  _impl_.ints_.InternalSwap(&other->_impl_.ints_);
  _impl_.strings_.InternalSwap(&other->_impl_.strings_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.s_, lhs_arena,
      &other->_impl_.s_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SPLayer_Attribute, _impl_.type_)
      + sizeof(SPLayer_Attribute::_impl_.type_)
      - PROTOBUF_FIELD_OFFSET(SPLayer_Attribute, _impl_.i_)>(
          reinterpret_cast<char*>(&_impl_.i_),
          reinterpret_cast<char*>(&other->_impl_.i_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer_Attribute::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[5]);
}

// ===================================================================

class SPLayer::_Internal {
 public:
  using HasBits = decltype(std::declval<SPLayer>()._impl_._has_bits_);
  static void set_has_id(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::sapeon::simulator::SPLayer_SPTensor& output(const SPLayer* msg);
  static void set_has_output(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::sapeon::simulator::SPLayer_SPTensor& filter(const SPLayer* msg);
  static void set_has_filter(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::sapeon::simulator::SPLayer_SPTensor& bias(const SPLayer* msg);
  static void set_has_bias(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::sapeon::simulator::SPLayer_SPTensor& scale(const SPLayer* msg);
  static void set_has_scale(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::sapeon::simulator::SPLayer_SPTensor& mean(const SPLayer* msg);
  static void set_has_mean(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::sapeon::simulator::SPLayer_SPTensor& variance(const SPLayer* msg);
  static void set_has_variance(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_epsilon(HasBits* has_bits) {
    (*has_bits)[0] |= 8192u;
  }
  static void set_has_output_threshold(HasBits* has_bits) {
    (*has_bits)[0] |= 4096u;
  }
  static const ::sapeon::simulator::SPLayer_SPConvolutionDesc& convdesc(const SPLayer* msg);
  static void set_has_convdesc(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::sapeon::simulator::SPLayer_SPSamplingDesc& samplingdesc(const SPLayer* msg);
  static void set_has_samplingdesc(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::sapeon::simulator::SPLayer_SPEWAddDesc& ewadddesc(const SPLayer* msg);
  static void set_has_ewadddesc(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::sapeon::simulator::SPLayer_SPEWMulDesc& ewmuldesc(const SPLayer* msg);
  static void set_has_ewmuldesc(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_activation(HasBits* has_bits) {
    (*has_bits)[0] |= 16384u;
  }
  static bool MissingRequiredFields(const HasBits& has_bits) {
    return ((has_bits[0] & 0x00000800) ^ 0x00000800) != 0;
  }
};

const ::sapeon::simulator::SPLayer_SPTensor&
SPLayer::_Internal::output(const SPLayer* msg) {
  return *msg->_impl_.output_;
}
const ::sapeon::simulator::SPLayer_SPTensor&
SPLayer::_Internal::filter(const SPLayer* msg) {
  return *msg->_impl_.filter_;
}
const ::sapeon::simulator::SPLayer_SPTensor&
SPLayer::_Internal::bias(const SPLayer* msg) {
  return *msg->_impl_.bias_;
}
const ::sapeon::simulator::SPLayer_SPTensor&
SPLayer::_Internal::scale(const SPLayer* msg) {
  return *msg->_impl_.scale_;
}
const ::sapeon::simulator::SPLayer_SPTensor&
SPLayer::_Internal::mean(const SPLayer* msg) {
  return *msg->_impl_.mean_;
}
const ::sapeon::simulator::SPLayer_SPTensor&
SPLayer::_Internal::variance(const SPLayer* msg) {
  return *msg->_impl_.variance_;
}
const ::sapeon::simulator::SPLayer_SPConvolutionDesc&
SPLayer::_Internal::convdesc(const SPLayer* msg) {
  return *msg->_impl_.convdesc_;
}
const ::sapeon::simulator::SPLayer_SPSamplingDesc&
SPLayer::_Internal::samplingdesc(const SPLayer* msg) {
  return *msg->_impl_.samplingdesc_;
}
const ::sapeon::simulator::SPLayer_SPEWAddDesc&
SPLayer::_Internal::ewadddesc(const SPLayer* msg) {
  return *msg->_impl_.ewadddesc_;
}
const ::sapeon::simulator::SPLayer_SPEWMulDesc&
SPLayer::_Internal::ewmuldesc(const SPLayer* msg) {
  return *msg->_impl_.ewmuldesc_;
}
SPLayer::SPLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPLayer)
}
SPLayer::SPLayer(const SPLayer& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPLayer* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){from._impl_.type_}
    , decltype(_impl_.preds_){from._impl_.preds_}
    , decltype(_impl_.succs_){from._impl_.succs_}
    , decltype(_impl_.input_){from._impl_.input_}
    , decltype(_impl_.input_threshold_){from._impl_.input_threshold_}
    , decltype(_impl_.filter_threshold_){from._impl_.filter_threshold_}
    , decltype(_impl_.attributes_){from._impl_.attributes_}
    , decltype(_impl_.name_){}
    , decltype(_impl_.output_){nullptr}
    , decltype(_impl_.filter_){nullptr}
    , decltype(_impl_.bias_){nullptr}
    , decltype(_impl_.scale_){nullptr}
    , decltype(_impl_.mean_){nullptr}
    , decltype(_impl_.variance_){nullptr}
    , decltype(_impl_.convdesc_){nullptr}
    , decltype(_impl_.samplingdesc_){nullptr}
    , decltype(_impl_.ewadddesc_){nullptr}
    , decltype(_impl_.ewmuldesc_){nullptr}
    , decltype(_impl_.id_){}
    , decltype(_impl_.output_threshold_){}
    , decltype(_impl_.epsilon_){}
    , decltype(_impl_.activation_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (from._internal_has_name()) {
    _this->_impl_.name_.Set(from._internal_name(), 
      _this->GetArenaForAllocation());
  }
  if (from._internal_has_output()) {
    _this->_impl_.output_ = new ::sapeon::simulator::SPLayer_SPTensor(*from._impl_.output_);
  }
  if (from._internal_has_filter()) {
    _this->_impl_.filter_ = new ::sapeon::simulator::SPLayer_SPTensor(*from._impl_.filter_);
  }
  if (from._internal_has_bias()) {
    _this->_impl_.bias_ = new ::sapeon::simulator::SPLayer_SPTensor(*from._impl_.bias_);
  }
  if (from._internal_has_scale()) {
    _this->_impl_.scale_ = new ::sapeon::simulator::SPLayer_SPTensor(*from._impl_.scale_);
  }
  if (from._internal_has_mean()) {
    _this->_impl_.mean_ = new ::sapeon::simulator::SPLayer_SPTensor(*from._impl_.mean_);
  }
  if (from._internal_has_variance()) {
    _this->_impl_.variance_ = new ::sapeon::simulator::SPLayer_SPTensor(*from._impl_.variance_);
  }
  if (from._internal_has_convdesc()) {
    _this->_impl_.convdesc_ = new ::sapeon::simulator::SPLayer_SPConvolutionDesc(*from._impl_.convdesc_);
  }
  if (from._internal_has_samplingdesc()) {
    _this->_impl_.samplingdesc_ = new ::sapeon::simulator::SPLayer_SPSamplingDesc(*from._impl_.samplingdesc_);
  }
  if (from._internal_has_ewadddesc()) {
    _this->_impl_.ewadddesc_ = new ::sapeon::simulator::SPLayer_SPEWAddDesc(*from._impl_.ewadddesc_);
  }
  if (from._internal_has_ewmuldesc()) {
    _this->_impl_.ewmuldesc_ = new ::sapeon::simulator::SPLayer_SPEWMulDesc(*from._impl_.ewmuldesc_);
  }
  ::memcpy(&_impl_.id_, &from._impl_.id_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.activation_) -
    reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.activation_));
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPLayer)
}

inline void SPLayer::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.type_){arena}
    , decltype(_impl_.preds_){arena}
    , decltype(_impl_.succs_){arena}
    , decltype(_impl_.input_){arena}
    , decltype(_impl_.input_threshold_){arena}
    , decltype(_impl_.filter_threshold_){arena}
    , decltype(_impl_.attributes_){arena}
    , decltype(_impl_.name_){}
    , decltype(_impl_.output_){nullptr}
    , decltype(_impl_.filter_){nullptr}
    , decltype(_impl_.bias_){nullptr}
    , decltype(_impl_.scale_){nullptr}
    , decltype(_impl_.mean_){nullptr}
    , decltype(_impl_.variance_){nullptr}
    , decltype(_impl_.convdesc_){nullptr}
    , decltype(_impl_.samplingdesc_){nullptr}
    , decltype(_impl_.ewadddesc_){nullptr}
    , decltype(_impl_.ewmuldesc_){nullptr}
    , decltype(_impl_.id_){0}
    , decltype(_impl_.output_threshold_){0}
    , decltype(_impl_.epsilon_){0}
    , decltype(_impl_.activation_){0}
  };
  _impl_.name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    _impl_.name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

SPLayer::~SPLayer() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPLayer)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPLayer::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.type_.~RepeatedPtrField();
  _impl_.preds_.~RepeatedField();
  _impl_.succs_.~RepeatedField();
  _impl_.input_.~RepeatedPtrField();
  _impl_.input_threshold_.~RepeatedField();
  _impl_.filter_threshold_.~RepeatedField();
  _impl_.attributes_.~RepeatedPtrField();
  _impl_.name_.Destroy();
  if (this != internal_default_instance()) delete _impl_.output_;
  if (this != internal_default_instance()) delete _impl_.filter_;
  if (this != internal_default_instance()) delete _impl_.bias_;
  if (this != internal_default_instance()) delete _impl_.scale_;
  if (this != internal_default_instance()) delete _impl_.mean_;
  if (this != internal_default_instance()) delete _impl_.variance_;
  if (this != internal_default_instance()) delete _impl_.convdesc_;
  if (this != internal_default_instance()) delete _impl_.samplingdesc_;
  if (this != internal_default_instance()) delete _impl_.ewadddesc_;
  if (this != internal_default_instance()) delete _impl_.ewmuldesc_;
}

void SPLayer::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPLayer::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPLayer)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.type_.Clear();
  _impl_.preds_.Clear();
  _impl_.succs_.Clear();
  _impl_.input_.Clear();
  _impl_.input_threshold_.Clear();
  _impl_.filter_threshold_.Clear();
  _impl_.attributes_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _impl_.name_.ClearNonDefaultToEmpty();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(_impl_.output_ != nullptr);
      _impl_.output_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(_impl_.filter_ != nullptr);
      _impl_.filter_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(_impl_.bias_ != nullptr);
      _impl_.bias_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(_impl_.scale_ != nullptr);
      _impl_.scale_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(_impl_.mean_ != nullptr);
      _impl_.mean_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(_impl_.variance_ != nullptr);
      _impl_.variance_->Clear();
    }
    if (cached_has_bits & 0x00000080u) {
      GOOGLE_DCHECK(_impl_.convdesc_ != nullptr);
      _impl_.convdesc_->Clear();
    }
  }
  if (cached_has_bits & 0x00000700u) {
    if (cached_has_bits & 0x00000100u) {
      GOOGLE_DCHECK(_impl_.samplingdesc_ != nullptr);
      _impl_.samplingdesc_->Clear();
    }
    if (cached_has_bits & 0x00000200u) {
      GOOGLE_DCHECK(_impl_.ewadddesc_ != nullptr);
      _impl_.ewadddesc_->Clear();
    }
    if (cached_has_bits & 0x00000400u) {
      GOOGLE_DCHECK(_impl_.ewmuldesc_ != nullptr);
      _impl_.ewmuldesc_->Clear();
    }
  }
  if (cached_has_bits & 0x00007800u) {
    ::memset(&_impl_.id_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&_impl_.activation_) -
        reinterpret_cast<char*>(&_impl_.id_)) + sizeof(_impl_.activation_));
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPLayer::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // required int32 id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          _Internal::set_has_id(&has_bits);
          _impl_.id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          #ifndef NDEBUG
          ::_pbi::VerifyUTF8(str, "sapeon.simulator.SPLayer.name");
          #endif  // !NDEBUG
        } else
          goto handle_unusual;
        continue;
      // repeated string type = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_type();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            #ifndef NDEBUG
            ::_pbi::VerifyUTF8(str, "sapeon.simulator.SPLayer.type");
            #endif  // !NDEBUG
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 preds = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_preds(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<32>(ptr));
        } else if (static_cast<uint8_t>(tag) == 34) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_preds(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 succs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_succs(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<40>(ptr));
        } else if (static_cast<uint8_t>(tag) == 42) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_succs(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .sapeon.simulator.SPLayer.SPTensor input = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_input(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<50>(ptr));
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPTensor output = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr = ctx->ParseMessage(_internal_mutable_output(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPTensor filter = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_filter(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPTensor bias = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_bias(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPTensor scale = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 82)) {
          ptr = ctx->ParseMessage(_internal_mutable_scale(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPTensor mean = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 90)) {
          ptr = ctx->ParseMessage(_internal_mutable_mean(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPTensor variance = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 98)) {
          ptr = ctx->ParseMessage(_internal_mutable_variance(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated float input_threshold = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 109)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_input_threshold(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<109>(ptr));
        } else if (static_cast<uint8_t>(tag) == 106) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_input_threshold(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float output_threshold = 14;
      case 14:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 117)) {
          _Internal::set_has_output_threshold(&has_bits);
          _impl_.output_threshold_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // repeated float filter_threshold = 15;
      case 15:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 125)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_filter_threshold(::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr));
            ptr += sizeof(float);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<125>(ptr));
        } else if (static_cast<uint8_t>(tag) == 122) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedFloatParser(_internal_mutable_filter_threshold(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional float epsilon = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 133)) {
          _Internal::set_has_epsilon(&has_bits);
          _impl_.epsilon_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<float>(ptr);
          ptr += sizeof(float);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPConvolutionDesc convdesc = 20;
      case 20:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 162)) {
          ptr = ctx->ParseMessage(_internal_mutable_convdesc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPSamplingDesc samplingdesc = 21;
      case 21:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 170)) {
          ptr = ctx->ParseMessage(_internal_mutable_samplingdesc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPEWAddDesc ewadddesc = 22;
      case 22:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 178)) {
          ptr = ctx->ParseMessage(_internal_mutable_ewadddesc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPEWMulDesc ewmuldesc = 23;
      case 23:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 186)) {
          ptr = ctx->ParseMessage(_internal_mutable_ewmuldesc(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional .sapeon.simulator.SPLayer.SPActivationMode activation = 30;
      case 30:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 240)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::sapeon::simulator::SPLayer_SPActivationMode_IsValid(val))) {
            _internal_set_activation(static_cast<::sapeon::simulator::SPLayer_SPActivationMode>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(30, val, mutable_unknown_fields());
          }
        } else
          goto handle_unusual;
        continue;
      // repeated .sapeon.simulator.SPLayer.Attribute attributes = 31;
      case 31:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 250)) {
          ptr -= 2;
          do {
            ptr += 2;
            ptr = ctx->ParseMessage(_internal_add_attributes(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<250>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPLayer::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPLayer)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _impl_._has_bits_[0];
  // required int32 id = 1;
  if (cached_has_bits & 0x00000800u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_id(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sapeon.simulator.SPLayer.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // repeated string type = 3;
  for (int i = 0, n = this->_internal_type_size(); i < n; i++) {
    const auto& s = this->_internal_type(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "sapeon.simulator.SPLayer.type");
    target = stream->WriteString(3, s, target);
  }

  // repeated int32 preds = 4;
  for (int i = 0, n = this->_internal_preds_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_preds(i), target);
  }

  // repeated int32 succs = 5;
  for (int i = 0, n = this->_internal_succs_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(5, this->_internal_succs(i), target);
  }

  // repeated .sapeon.simulator.SPLayer.SPTensor input = 6;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_input_size()); i < n; i++) {
    const auto& repfield = this->_internal_input(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(6, repfield, repfield.GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPTensor output = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(7, _Internal::output(this),
        _Internal::output(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPTensor filter = 8;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::filter(this),
        _Internal::filter(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPTensor bias = 9;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::bias(this),
        _Internal::bias(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPTensor scale = 10;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(10, _Internal::scale(this),
        _Internal::scale(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPTensor mean = 11;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(11, _Internal::mean(this),
        _Internal::mean(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPTensor variance = 12;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(12, _Internal::variance(this),
        _Internal::variance(this).GetCachedSize(), target, stream);
  }

  // repeated float input_threshold = 13;
  for (int i = 0, n = this->_internal_input_threshold_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(13, this->_internal_input_threshold(i), target);
  }

  // optional float output_threshold = 14;
  if (cached_has_bits & 0x00001000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(14, this->_internal_output_threshold(), target);
  }

  // repeated float filter_threshold = 15;
  for (int i = 0, n = this->_internal_filter_threshold_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(15, this->_internal_filter_threshold(i), target);
  }

  // optional float epsilon = 16;
  if (cached_has_bits & 0x00002000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteFloatToArray(16, this->_internal_epsilon(), target);
  }

  // optional .sapeon.simulator.SPLayer.SPConvolutionDesc convdesc = 20;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(20, _Internal::convdesc(this),
        _Internal::convdesc(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPSamplingDesc samplingdesc = 21;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(21, _Internal::samplingdesc(this),
        _Internal::samplingdesc(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPEWAddDesc ewadddesc = 22;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(22, _Internal::ewadddesc(this),
        _Internal::ewadddesc(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPEWMulDesc ewmuldesc = 23;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(23, _Internal::ewmuldesc(this),
        _Internal::ewmuldesc(this).GetCachedSize(), target, stream);
  }

  // optional .sapeon.simulator.SPLayer.SPActivationMode activation = 30;
  if (cached_has_bits & 0x00004000u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      30, this->_internal_activation(), target);
  }

  // repeated .sapeon.simulator.SPLayer.Attribute attributes = 31;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attributes_size()); i < n; i++) {
    const auto& repfield = this->_internal_attributes(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(31, repfield, repfield.GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPLayer)
  return target;
}

size_t SPLayer::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPLayer)
  size_t total_size = 0;

  // required int32 id = 1;
  if (_internal_has_id()) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string type = 3;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(_impl_.type_.size());
  for (int i = 0, n = _impl_.type_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      _impl_.type_.Get(i));
  }

  // repeated int32 preds = 4;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.preds_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_preds_size());
    total_size += data_size;
  }

  // repeated int32 succs = 5;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.succs_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_succs_size());
    total_size += data_size;
  }

  // repeated .sapeon.simulator.SPLayer.SPTensor input = 6;
  total_size += 1UL * this->_internal_input_size();
  for (const auto& msg : this->_impl_.input_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated float input_threshold = 13;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_input_threshold_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_input_threshold_size());
    total_size += data_size;
  }

  // repeated float filter_threshold = 15;
  {
    unsigned int count = static_cast<unsigned int>(this->_internal_filter_threshold_size());
    size_t data_size = 4UL * count;
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_filter_threshold_size());
    total_size += data_size;
  }

  // repeated .sapeon.simulator.SPLayer.Attribute attributes = 31;
  total_size += 2UL * this->_internal_attributes_size();
  for (const auto& msg : this->_impl_.attributes_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->_internal_name());
    }

    // optional .sapeon.simulator.SPLayer.SPTensor output = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.output_);
    }

    // optional .sapeon.simulator.SPLayer.SPTensor filter = 8;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.filter_);
    }

    // optional .sapeon.simulator.SPLayer.SPTensor bias = 9;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.bias_);
    }

    // optional .sapeon.simulator.SPLayer.SPTensor scale = 10;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.scale_);
    }

    // optional .sapeon.simulator.SPLayer.SPTensor mean = 11;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.mean_);
    }

    // optional .sapeon.simulator.SPLayer.SPTensor variance = 12;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.variance_);
    }

    // optional .sapeon.simulator.SPLayer.SPConvolutionDesc convdesc = 20;
    if (cached_has_bits & 0x00000080u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.convdesc_);
    }

  }
  if (cached_has_bits & 0x00000700u) {
    // optional .sapeon.simulator.SPLayer.SPSamplingDesc samplingdesc = 21;
    if (cached_has_bits & 0x00000100u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.samplingdesc_);
    }

    // optional .sapeon.simulator.SPLayer.SPEWAddDesc ewadddesc = 22;
    if (cached_has_bits & 0x00000200u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ewadddesc_);
    }

    // optional .sapeon.simulator.SPLayer.SPEWMulDesc ewmuldesc = 23;
    if (cached_has_bits & 0x00000400u) {
      total_size += 2 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *_impl_.ewmuldesc_);
    }

  }
  if (cached_has_bits & 0x00007000u) {
    // optional float output_threshold = 14;
    if (cached_has_bits & 0x00001000u) {
      total_size += 1 + 4;
    }

    // optional float epsilon = 16;
    if (cached_has_bits & 0x00002000u) {
      total_size += 2 + 4;
    }

    // optional .sapeon.simulator.SPLayer.SPActivationMode activation = 30;
    if (cached_has_bits & 0x00004000u) {
      total_size += 2 +
        ::_pbi::WireFormatLite::EnumSize(this->_internal_activation());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPLayer::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPLayer::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPLayer::GetClassData() const { return &_class_data_; }


void SPLayer::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPLayer*>(&to_msg);
  auto& from = static_cast<const SPLayer&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPLayer)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.type_.MergeFrom(from._impl_.type_);
  _this->_impl_.preds_.MergeFrom(from._impl_.preds_);
  _this->_impl_.succs_.MergeFrom(from._impl_.succs_);
  _this->_impl_.input_.MergeFrom(from._impl_.input_);
  _this->_impl_.input_threshold_.MergeFrom(from._impl_.input_threshold_);
  _this->_impl_.filter_threshold_.MergeFrom(from._impl_.filter_threshold_);
  _this->_impl_.attributes_.MergeFrom(from._impl_.attributes_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _this->_internal_set_name(from._internal_name());
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_internal_mutable_output()->::sapeon::simulator::SPLayer_SPTensor::MergeFrom(
          from._internal_output());
    }
    if (cached_has_bits & 0x00000004u) {
      _this->_internal_mutable_filter()->::sapeon::simulator::SPLayer_SPTensor::MergeFrom(
          from._internal_filter());
    }
    if (cached_has_bits & 0x00000008u) {
      _this->_internal_mutable_bias()->::sapeon::simulator::SPLayer_SPTensor::MergeFrom(
          from._internal_bias());
    }
    if (cached_has_bits & 0x00000010u) {
      _this->_internal_mutable_scale()->::sapeon::simulator::SPLayer_SPTensor::MergeFrom(
          from._internal_scale());
    }
    if (cached_has_bits & 0x00000020u) {
      _this->_internal_mutable_mean()->::sapeon::simulator::SPLayer_SPTensor::MergeFrom(
          from._internal_mean());
    }
    if (cached_has_bits & 0x00000040u) {
      _this->_internal_mutable_variance()->::sapeon::simulator::SPLayer_SPTensor::MergeFrom(
          from._internal_variance());
    }
    if (cached_has_bits & 0x00000080u) {
      _this->_internal_mutable_convdesc()->::sapeon::simulator::SPLayer_SPConvolutionDesc::MergeFrom(
          from._internal_convdesc());
    }
  }
  if (cached_has_bits & 0x00007f00u) {
    if (cached_has_bits & 0x00000100u) {
      _this->_internal_mutable_samplingdesc()->::sapeon::simulator::SPLayer_SPSamplingDesc::MergeFrom(
          from._internal_samplingdesc());
    }
    if (cached_has_bits & 0x00000200u) {
      _this->_internal_mutable_ewadddesc()->::sapeon::simulator::SPLayer_SPEWAddDesc::MergeFrom(
          from._internal_ewadddesc());
    }
    if (cached_has_bits & 0x00000400u) {
      _this->_internal_mutable_ewmuldesc()->::sapeon::simulator::SPLayer_SPEWMulDesc::MergeFrom(
          from._internal_ewmuldesc());
    }
    if (cached_has_bits & 0x00000800u) {
      _this->_impl_.id_ = from._impl_.id_;
    }
    if (cached_has_bits & 0x00001000u) {
      _this->_impl_.output_threshold_ = from._impl_.output_threshold_;
    }
    if (cached_has_bits & 0x00002000u) {
      _this->_impl_.epsilon_ = from._impl_.epsilon_;
    }
    if (cached_has_bits & 0x00004000u) {
      _this->_impl_.activation_ = from._impl_.activation_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPLayer::CopyFrom(const SPLayer& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPLayer)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPLayer::IsInitialized() const {
  if (_Internal::MissingRequiredFields(_impl_._has_bits_)) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.input_))
    return false;
  if (_internal_has_output()) {
    if (!_impl_.output_->IsInitialized()) return false;
  }
  if (_internal_has_filter()) {
    if (!_impl_.filter_->IsInitialized()) return false;
  }
  if (_internal_has_bias()) {
    if (!_impl_.bias_->IsInitialized()) return false;
  }
  if (_internal_has_scale()) {
    if (!_impl_.scale_->IsInitialized()) return false;
  }
  if (_internal_has_mean()) {
    if (!_impl_.mean_->IsInitialized()) return false;
  }
  if (_internal_has_variance()) {
    if (!_impl_.variance_->IsInitialized()) return false;
  }
  if (_internal_has_convdesc()) {
    if (!_impl_.convdesc_->IsInitialized()) return false;
  }
  if (_internal_has_samplingdesc()) {
    if (!_impl_.samplingdesc_->IsInitialized()) return false;
  }
  return true;
}

void SPLayer::InternalSwap(SPLayer* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.type_.InternalSwap(&other->_impl_.type_);
  _impl_.preds_.InternalSwap(&other->_impl_.preds_);
  _impl_.succs_.InternalSwap(&other->_impl_.succs_);
  _impl_.input_.InternalSwap(&other->_impl_.input_);
  _impl_.input_threshold_.InternalSwap(&other->_impl_.input_threshold_);
  _impl_.filter_threshold_.InternalSwap(&other->_impl_.filter_threshold_);
  _impl_.attributes_.InternalSwap(&other->_impl_.attributes_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &_impl_.name_, lhs_arena,
      &other->_impl_.name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(SPLayer, _impl_.activation_)
      + sizeof(SPLayer::_impl_.activation_)
      - PROTOBUF_FIELD_OFFSET(SPLayer, _impl_.output_)>(
          reinterpret_cast<char*>(&_impl_.output_),
          reinterpret_cast<char*>(&other->_impl_.output_));
}

::PROTOBUF_NAMESPACE_ID::Metadata SPLayer::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[6]);
}

// ===================================================================

class SPGraph::_Internal {
 public:
  using HasBits = decltype(std::declval<SPGraph>()._impl_._has_bits_);
  static void set_has_ir_version(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_is_optimized(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

SPGraph::SPGraph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::Message(arena, is_message_owned) {
  SharedCtor(arena, is_message_owned);
  // @@protoc_insertion_point(arena_constructor:sapeon.simulator.SPGraph)
}
SPGraph::SPGraph(const SPGraph& from)
  : ::PROTOBUF_NAMESPACE_ID::Message() {
  SPGraph* const _this = this; (void)_this;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){from._impl_._has_bits_}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.layer_){from._impl_.layer_}
    , decltype(_impl_.input_layers_){from._impl_.input_layers_}
    , decltype(_impl_.output_layers_){from._impl_.output_layers_}
    , decltype(_impl_.is_optimized_){}
    , decltype(_impl_.ir_version_){}};

  _internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
  ::memcpy(&_impl_.is_optimized_, &from._impl_.is_optimized_,
    static_cast<size_t>(reinterpret_cast<char*>(&_impl_.ir_version_) -
    reinterpret_cast<char*>(&_impl_.is_optimized_)) + sizeof(_impl_.ir_version_));
  // @@protoc_insertion_point(copy_constructor:sapeon.simulator.SPGraph)
}

inline void SPGraph::SharedCtor(
    ::_pb::Arena* arena, bool is_message_owned) {
  (void)arena;
  (void)is_message_owned;
  new (&_impl_) Impl_{
      decltype(_impl_._has_bits_){}
    , /*decltype(_impl_._cached_size_)*/{}
    , decltype(_impl_.layer_){arena}
    , decltype(_impl_.input_layers_){arena}
    , decltype(_impl_.output_layers_){arena}
    , decltype(_impl_.is_optimized_){false}
    , decltype(_impl_.ir_version_){int64_t{2}}
  };
}

SPGraph::~SPGraph() {
  // @@protoc_insertion_point(destructor:sapeon.simulator.SPGraph)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void SPGraph::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  _impl_.layer_.~RepeatedPtrField();
  _impl_.input_layers_.~RepeatedField();
  _impl_.output_layers_.~RepeatedField();
}

void SPGraph::SetCachedSize(int size) const {
  _impl_._cached_size_.Set(size);
}

void SPGraph::Clear() {
// @@protoc_insertion_point(message_clear_start:sapeon.simulator.SPGraph)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  _impl_.layer_.Clear();
  _impl_.input_layers_.Clear();
  _impl_.output_layers_.Clear();
  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    _impl_.is_optimized_ = false;
    _impl_.ir_version_ = int64_t{2};
  }
  _impl_._has_bits_.Clear();
  _internal_metadata_.Clear<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
}

const char* SPGraph::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .sapeon.simulator.SPLayer layer = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_layer(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated int32 input_layers = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_input_layers(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<16>(ptr));
        } else if (static_cast<uint8_t>(tag) == 18) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_input_layers(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated int32 output_layers = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          ptr -= 1;
          do {
            ptr += 1;
            _internal_add_output_layers(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr));
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<24>(ptr));
        } else if (static_cast<uint8_t>(tag) == 26) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::PackedInt32Parser(_internal_mutable_output_layers(), ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional int64 ir_version = 4 [default = 2];
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          _Internal::set_has_ir_version(&has_bits);
          _impl_.ir_version_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // optional bool is_optimized = 5 [default = false];
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          _Internal::set_has_is_optimized(&has_bits);
          _impl_.is_optimized_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  _impl_._has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* SPGraph::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:sapeon.simulator.SPGraph)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .sapeon.simulator.SPLayer layer = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_layer_size()); i < n; i++) {
    const auto& repfield = this->_internal_layer(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated int32 input_layers = 2;
  for (int i = 0, n = this->_internal_input_layers_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_input_layers(i), target);
  }

  // repeated int32 output_layers = 3;
  for (int i = 0, n = this->_internal_output_layers_size(); i < n; i++) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_output_layers(i), target);
  }

  cached_has_bits = _impl_._has_bits_[0];
  // optional int64 ir_version = 4 [default = 2];
  if (cached_has_bits & 0x00000002u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_ir_version(), target);
  }

  // optional bool is_optimized = 5 [default = false];
  if (cached_has_bits & 0x00000001u) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_is_optimized(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = ::_pbi::WireFormat::InternalSerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance), target, stream);
  }
  // @@protoc_insertion_point(serialize_to_array_end:sapeon.simulator.SPGraph)
  return target;
}

size_t SPGraph::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:sapeon.simulator.SPGraph)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .sapeon.simulator.SPLayer layer = 1;
  total_size += 1UL * this->_internal_layer_size();
  for (const auto& msg : this->_impl_.layer_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated int32 input_layers = 2;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.input_layers_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_input_layers_size());
    total_size += data_size;
  }

  // repeated int32 output_layers = 3;
  {
    size_t data_size = ::_pbi::WireFormatLite::
      Int32Size(this->_impl_.output_layers_);
    total_size += 1 *
                  ::_pbi::FromIntSize(this->_internal_output_layers_size());
    total_size += data_size;
  }

  cached_has_bits = _impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    // optional bool is_optimized = 5 [default = false];
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 + 1;
    }

    // optional int64 ir_version = 4 [default = 2];
    if (cached_has_bits & 0x00000002u) {
      total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_ir_version());
    }

  }
  return MaybeComputeUnknownFieldsSize(total_size, &_impl_._cached_size_);
}

const ::PROTOBUF_NAMESPACE_ID::Message::ClassData SPGraph::_class_data_ = {
    ::PROTOBUF_NAMESPACE_ID::Message::CopyWithSourceCheck,
    SPGraph::MergeImpl
};
const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*SPGraph::GetClassData() const { return &_class_data_; }


void SPGraph::MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg) {
  auto* const _this = static_cast<SPGraph*>(&to_msg);
  auto& from = static_cast<const SPGraph&>(from_msg);
  // @@protoc_insertion_point(class_specific_merge_from_start:sapeon.simulator.SPGraph)
  GOOGLE_DCHECK_NE(&from, _this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  _this->_impl_.layer_.MergeFrom(from._impl_.layer_);
  _this->_impl_.input_layers_.MergeFrom(from._impl_.input_layers_);
  _this->_impl_.output_layers_.MergeFrom(from._impl_.output_layers_);
  cached_has_bits = from._impl_._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _this->_impl_.is_optimized_ = from._impl_.is_optimized_;
    }
    if (cached_has_bits & 0x00000002u) {
      _this->_impl_.ir_version_ = from._impl_.ir_version_;
    }
    _this->_impl_._has_bits_[0] |= cached_has_bits;
  }
  _this->_internal_metadata_.MergeFrom<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(from._internal_metadata_);
}

void SPGraph::CopyFrom(const SPGraph& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:sapeon.simulator.SPGraph)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SPGraph::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(_impl_.layer_))
    return false;
  return true;
}

void SPGraph::InternalSwap(SPGraph* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(_impl_._has_bits_[0], other->_impl_._has_bits_[0]);
  _impl_.layer_.InternalSwap(&other->_impl_.layer_);
  _impl_.input_layers_.InternalSwap(&other->_impl_.input_layers_);
  _impl_.output_layers_.InternalSwap(&other->_impl_.output_layers_);
  swap(_impl_.is_optimized_, other->_impl_.is_optimized_);
  swap(_impl_.ir_version_, other->_impl_.ir_version_);
}

::PROTOBUF_NAMESPACE_ID::Metadata SPGraph::GetMetadata() const {
  return ::_pbi::AssignDescriptors(
      &descriptor_table_spear_2eproto_2ee8e8_getter, &descriptor_table_spear_2eproto_2ee8e8_once,
      file_level_metadata_spear_2eproto_2ee8e8[7]);
}

// @@protoc_insertion_point(namespace_scope)
}  // namespace simulator
}  // namespace sapeon
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer_SPConvolutionDesc*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer_SPConvolutionDesc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer_SPConvolutionDesc >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer_SPSamplingDesc*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer_SPSamplingDesc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer_SPSamplingDesc >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer_SPEWAddDesc*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer_SPEWAddDesc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer_SPEWAddDesc >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer_SPEWMulDesc*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer_SPEWMulDesc >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer_SPEWMulDesc >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer_SPTensor*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer_SPTensor >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer_SPTensor >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer_Attribute*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer_Attribute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer_Attribute >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPLayer*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPLayer >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPLayer >(arena);
}
template<> PROTOBUF_NOINLINE ::sapeon::simulator::SPGraph*
Arena::CreateMaybeMessage< ::sapeon::simulator::SPGraph >(Arena* arena) {
  return Arena::CreateMessageInternal< ::sapeon::simulator::SPGraph >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
