// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: spear.proto.e8e8

#ifndef GOOGLE_PROTOBUF_INCLUDED_spear_2eproto_2ee8e8
#define GOOGLE_PROTOBUF_INCLUDED_spear_2eproto_2ee8e8

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021012 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_spear_2eproto_2ee8e8
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_spear_2eproto_2ee8e8 {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_spear_2eproto_2ee8e8;
namespace sapeon {
namespace simulator {
class SPGraph;
struct SPGraphDefaultTypeInternal;
extern SPGraphDefaultTypeInternal _SPGraph_default_instance_;
class SPLayer;
struct SPLayerDefaultTypeInternal;
extern SPLayerDefaultTypeInternal _SPLayer_default_instance_;
class SPLayer_Attribute;
struct SPLayer_AttributeDefaultTypeInternal;
extern SPLayer_AttributeDefaultTypeInternal _SPLayer_Attribute_default_instance_;
class SPLayer_SPConvolutionDesc;
struct SPLayer_SPConvolutionDescDefaultTypeInternal;
extern SPLayer_SPConvolutionDescDefaultTypeInternal _SPLayer_SPConvolutionDesc_default_instance_;
class SPLayer_SPEWAddDesc;
struct SPLayer_SPEWAddDescDefaultTypeInternal;
extern SPLayer_SPEWAddDescDefaultTypeInternal _SPLayer_SPEWAddDesc_default_instance_;
class SPLayer_SPEWMulDesc;
struct SPLayer_SPEWMulDescDefaultTypeInternal;
extern SPLayer_SPEWMulDescDefaultTypeInternal _SPLayer_SPEWMulDesc_default_instance_;
class SPLayer_SPSamplingDesc;
struct SPLayer_SPSamplingDescDefaultTypeInternal;
extern SPLayer_SPSamplingDescDefaultTypeInternal _SPLayer_SPSamplingDesc_default_instance_;
class SPLayer_SPTensor;
struct SPLayer_SPTensorDefaultTypeInternal;
extern SPLayer_SPTensorDefaultTypeInternal _SPLayer_SPTensor_default_instance_;
}  // namespace simulator
}  // namespace sapeon
PROTOBUF_NAMESPACE_OPEN
template<> ::sapeon::simulator::SPGraph* Arena::CreateMaybeMessage<::sapeon::simulator::SPGraph>(Arena*);
template<> ::sapeon::simulator::SPLayer* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer>(Arena*);
template<> ::sapeon::simulator::SPLayer_Attribute* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer_Attribute>(Arena*);
template<> ::sapeon::simulator::SPLayer_SPConvolutionDesc* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer_SPConvolutionDesc>(Arena*);
template<> ::sapeon::simulator::SPLayer_SPEWAddDesc* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer_SPEWAddDesc>(Arena*);
template<> ::sapeon::simulator::SPLayer_SPEWMulDesc* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer_SPEWMulDesc>(Arena*);
template<> ::sapeon::simulator::SPLayer_SPSamplingDesc* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer_SPSamplingDesc>(Arena*);
template<> ::sapeon::simulator::SPLayer_SPTensor* Arena::CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace sapeon {
namespace simulator {

enum SPLayer_Attribute_AttributeType : int {
  SPLayer_Attribute_AttributeType_UNDEFINED = 0,
  SPLayer_Attribute_AttributeType_FLOAT = 1,
  SPLayer_Attribute_AttributeType_INT = 2,
  SPLayer_Attribute_AttributeType_STRING = 3,
  SPLayer_Attribute_AttributeType_FLOATS = 6,
  SPLayer_Attribute_AttributeType_INTS = 7,
  SPLayer_Attribute_AttributeType_STRINGS = 8
};
bool SPLayer_Attribute_AttributeType_IsValid(int value);
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute_AttributeType_AttributeType_MIN = SPLayer_Attribute_AttributeType_UNDEFINED;
constexpr SPLayer_Attribute_AttributeType SPLayer_Attribute_AttributeType_AttributeType_MAX = SPLayer_Attribute_AttributeType_STRINGS;
constexpr int SPLayer_Attribute_AttributeType_AttributeType_ARRAYSIZE = SPLayer_Attribute_AttributeType_AttributeType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_Attribute_AttributeType_descriptor();
template<typename T>
inline const std::string& SPLayer_Attribute_AttributeType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SPLayer_Attribute_AttributeType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SPLayer_Attribute_AttributeType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SPLayer_Attribute_AttributeType_descriptor(), enum_t_value);
}
inline bool SPLayer_Attribute_AttributeType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SPLayer_Attribute_AttributeType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SPLayer_Attribute_AttributeType>(
    SPLayer_Attribute_AttributeType_descriptor(), name, value);
}
enum SPLayer_SPActivationMode : int {
  SPLayer_SPActivationMode_SP_ACTIVATION_SIGMOID = 0,
  SPLayer_SPActivationMode_SP_ACTIVATION_RELU = 1,
  SPLayer_SPActivationMode_SP_ACTIVATION_LEAKY_RELU = 2,
  SPLayer_SPActivationMode_SP_ACTIVATION_PRELU = 3,
  SPLayer_SPActivationMode_SP_ACTIVATION_TANH = 4,
  SPLayer_SPActivationMode_SP_ACTIVATION_IDENTITY = 5,
  SPLayer_SPActivationMode_SP_ACTIVATION_MISH = 6,
  SPLayer_SPActivationMode_SP_ACTIVATION_RELU6 = 7,
  SPLayer_SPActivationMode_SP_ACTIVATION_SWISH = 8
};
bool SPLayer_SPActivationMode_IsValid(int value);
constexpr SPLayer_SPActivationMode SPLayer_SPActivationMode_SPActivationMode_MIN = SPLayer_SPActivationMode_SP_ACTIVATION_SIGMOID;
constexpr SPLayer_SPActivationMode SPLayer_SPActivationMode_SPActivationMode_MAX = SPLayer_SPActivationMode_SP_ACTIVATION_SWISH;
constexpr int SPLayer_SPActivationMode_SPActivationMode_ARRAYSIZE = SPLayer_SPActivationMode_SPActivationMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPActivationMode_descriptor();
template<typename T>
inline const std::string& SPLayer_SPActivationMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SPLayer_SPActivationMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SPLayer_SPActivationMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SPLayer_SPActivationMode_descriptor(), enum_t_value);
}
inline bool SPLayer_SPActivationMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SPLayer_SPActivationMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SPLayer_SPActivationMode>(
    SPLayer_SPActivationMode_descriptor(), name, value);
}
enum SPLayer_SPSamplingMode : int {
  SPLayer_SPSamplingMode_SP_POOLING_MAX = 0,
  SPLayer_SPSamplingMode_SP_POOLING_GLOBAL_AVERAGE = 1,
  SPLayer_SPSamplingMode_SP_POOLING_LOCAL_AVERAGE = 5,
  SPLayer_SPSamplingMode_SP_POOLING_REORG = 2,
  SPLayer_SPSamplingMode_SP_POOLING_UPSAMPLE = 3,
  SPLayer_SPSamplingMode_SP_POOLING_PIXELSHUFFLE = 4
};
bool SPLayer_SPSamplingMode_IsValid(int value);
constexpr SPLayer_SPSamplingMode SPLayer_SPSamplingMode_SPSamplingMode_MIN = SPLayer_SPSamplingMode_SP_POOLING_MAX;
constexpr SPLayer_SPSamplingMode SPLayer_SPSamplingMode_SPSamplingMode_MAX = SPLayer_SPSamplingMode_SP_POOLING_LOCAL_AVERAGE;
constexpr int SPLayer_SPSamplingMode_SPSamplingMode_ARRAYSIZE = SPLayer_SPSamplingMode_SPSamplingMode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPSamplingMode_descriptor();
template<typename T>
inline const std::string& SPLayer_SPSamplingMode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SPLayer_SPSamplingMode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SPLayer_SPSamplingMode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SPLayer_SPSamplingMode_descriptor(), enum_t_value);
}
inline bool SPLayer_SPSamplingMode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SPLayer_SPSamplingMode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SPLayer_SPSamplingMode>(
    SPLayer_SPSamplingMode_descriptor(), name, value);
}
enum SPLayer_SPDataType : int {
  SPLayer_SPDataType_SP_DATA_FLOAT = 0,
  SPLayer_SPDataType_SP_DATA_DOUBLE = 1,
  SPLayer_SPDataType_SP_DATA_HALF = 2,
  SPLayer_SPDataType_SP_DATA_UINT8 = 3,
  SPLayer_SPDataType_SP_DATA_SINT8 = 4,
  SPLayer_SPDataType_SP_DATA_SINT16 = 5
};
bool SPLayer_SPDataType_IsValid(int value);
constexpr SPLayer_SPDataType SPLayer_SPDataType_SPDataType_MIN = SPLayer_SPDataType_SP_DATA_FLOAT;
constexpr SPLayer_SPDataType SPLayer_SPDataType_SPDataType_MAX = SPLayer_SPDataType_SP_DATA_SINT16;
constexpr int SPLayer_SPDataType_SPDataType_ARRAYSIZE = SPLayer_SPDataType_SPDataType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPDataType_descriptor();
template<typename T>
inline const std::string& SPLayer_SPDataType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SPLayer_SPDataType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SPLayer_SPDataType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SPLayer_SPDataType_descriptor(), enum_t_value);
}
inline bool SPLayer_SPDataType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SPLayer_SPDataType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SPLayer_SPDataType>(
    SPLayer_SPDataType_descriptor(), name, value);
}
enum SPLayer_SPTensorFormat : int {
  SPLayer_SPTensorFormat_SP_FORMAT_NCHW = 0,
  SPLayer_SPTensorFormat_SP_FORMAT_NHWC = 1,
  SPLayer_SPTensorFormat_SP_FORMAT_NWHC = 2,
  SPLayer_SPTensorFormat_SP_FORMAT_VECTOR = 3
};
bool SPLayer_SPTensorFormat_IsValid(int value);
constexpr SPLayer_SPTensorFormat SPLayer_SPTensorFormat_SPTensorFormat_MIN = SPLayer_SPTensorFormat_SP_FORMAT_NCHW;
constexpr SPLayer_SPTensorFormat SPLayer_SPTensorFormat_SPTensorFormat_MAX = SPLayer_SPTensorFormat_SP_FORMAT_VECTOR;
constexpr int SPLayer_SPTensorFormat_SPTensorFormat_ARRAYSIZE = SPLayer_SPTensorFormat_SPTensorFormat_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SPLayer_SPTensorFormat_descriptor();
template<typename T>
inline const std::string& SPLayer_SPTensorFormat_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SPLayer_SPTensorFormat>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SPLayer_SPTensorFormat_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SPLayer_SPTensorFormat_descriptor(), enum_t_value);
}
inline bool SPLayer_SPTensorFormat_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SPLayer_SPTensorFormat* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SPLayer_SPTensorFormat>(
    SPLayer_SPTensorFormat_descriptor(), name, value);
}
// ===================================================================

class SPLayer_SPConvolutionDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer.SPConvolutionDesc) */ {
 public:
  inline SPLayer_SPConvolutionDesc() : SPLayer_SPConvolutionDesc(nullptr) {}
  ~SPLayer_SPConvolutionDesc() override;
  explicit PROTOBUF_CONSTEXPR SPLayer_SPConvolutionDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer_SPConvolutionDesc(const SPLayer_SPConvolutionDesc& from);
  SPLayer_SPConvolutionDesc(SPLayer_SPConvolutionDesc&& from) noexcept
    : SPLayer_SPConvolutionDesc() {
    *this = ::std::move(from);
  }

  inline SPLayer_SPConvolutionDesc& operator=(const SPLayer_SPConvolutionDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer_SPConvolutionDesc& operator=(SPLayer_SPConvolutionDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer_SPConvolutionDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer_SPConvolutionDesc* internal_default_instance() {
    return reinterpret_cast<const SPLayer_SPConvolutionDesc*>(
               &_SPLayer_SPConvolutionDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SPLayer_SPConvolutionDesc& a, SPLayer_SPConvolutionDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer_SPConvolutionDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer_SPConvolutionDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer_SPConvolutionDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer_SPConvolutionDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer_SPConvolutionDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer_SPConvolutionDesc& from) {
    SPLayer_SPConvolutionDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer_SPConvolutionDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer.SPConvolutionDesc";
  }
  protected:
  explicit SPLayer_SPConvolutionDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaddingFieldNumber = 2,
    kStrideFieldNumber = 3,
    kDilationFieldNumber = 4,
    kDtypeFieldNumber = 1,
    kGroupsFieldNumber = 5,
  };
  // repeated int32 padding = 2;
  int padding_size() const;
  private:
  int _internal_padding_size() const;
  public:
  void clear_padding();
  private:
  int32_t _internal_padding(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_padding() const;
  void _internal_add_padding(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_padding();
  public:
  int32_t padding(int index) const;
  void set_padding(int index, int32_t value);
  void add_padding(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      padding() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_padding();

  // repeated int32 stride = 3;
  int stride_size() const;
  private:
  int _internal_stride_size() const;
  public:
  void clear_stride();
  private:
  int32_t _internal_stride(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_stride() const;
  void _internal_add_stride(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_stride();
  public:
  int32_t stride(int index) const;
  void set_stride(int index, int32_t value);
  void add_stride(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      stride() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_stride();

  // repeated int32 dilation = 4;
  int dilation_size() const;
  private:
  int _internal_dilation_size() const;
  public:
  void clear_dilation();
  private:
  int32_t _internal_dilation(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_dilation() const;
  void _internal_add_dilation(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_dilation();
  public:
  int32_t dilation(int index) const;
  void set_dilation(int index, int32_t value);
  void add_dilation(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      dilation() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_dilation();

  // optional .sapeon.simulator.SPLayer.SPDataType dtype = 1;
  bool has_dtype() const;
  private:
  bool _internal_has_dtype() const;
  public:
  void clear_dtype();
  ::sapeon::simulator::SPLayer_SPDataType dtype() const;
  void set_dtype(::sapeon::simulator::SPLayer_SPDataType value);
  private:
  ::sapeon::simulator::SPLayer_SPDataType _internal_dtype() const;
  void _internal_set_dtype(::sapeon::simulator::SPLayer_SPDataType value);
  public:

  // required int32 groups = 5;
  bool has_groups() const;
  private:
  bool _internal_has_groups() const;
  public:
  void clear_groups();
  int32_t groups() const;
  void set_groups(int32_t value);
  private:
  int32_t _internal_groups() const;
  void _internal_set_groups(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer.SPConvolutionDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > padding_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > stride_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > dilation_;
    int dtype_;
    int32_t groups_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPLayer_SPSamplingDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer.SPSamplingDesc) */ {
 public:
  inline SPLayer_SPSamplingDesc() : SPLayer_SPSamplingDesc(nullptr) {}
  ~SPLayer_SPSamplingDesc() override;
  explicit PROTOBUF_CONSTEXPR SPLayer_SPSamplingDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer_SPSamplingDesc(const SPLayer_SPSamplingDesc& from);
  SPLayer_SPSamplingDesc(SPLayer_SPSamplingDesc&& from) noexcept
    : SPLayer_SPSamplingDesc() {
    *this = ::std::move(from);
  }

  inline SPLayer_SPSamplingDesc& operator=(const SPLayer_SPSamplingDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer_SPSamplingDesc& operator=(SPLayer_SPSamplingDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer_SPSamplingDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer_SPSamplingDesc* internal_default_instance() {
    return reinterpret_cast<const SPLayer_SPSamplingDesc*>(
               &_SPLayer_SPSamplingDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SPLayer_SPSamplingDesc& a, SPLayer_SPSamplingDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer_SPSamplingDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer_SPSamplingDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer_SPSamplingDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer_SPSamplingDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer_SPSamplingDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer_SPSamplingDesc& from) {
    SPLayer_SPSamplingDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer_SPSamplingDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer.SPSamplingDesc";
  }
  protected:
  explicit SPLayer_SPSamplingDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPaddingFieldNumber = 2,
    kStrideFieldNumber = 3,
    kWindowFieldNumber = 4,
    kModeFieldNumber = 1,
  };
  // repeated int32 padding = 2;
  int padding_size() const;
  private:
  int _internal_padding_size() const;
  public:
  void clear_padding();
  private:
  int32_t _internal_padding(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_padding() const;
  void _internal_add_padding(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_padding();
  public:
  int32_t padding(int index) const;
  void set_padding(int index, int32_t value);
  void add_padding(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      padding() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_padding();

  // repeated int32 stride = 3;
  int stride_size() const;
  private:
  int _internal_stride_size() const;
  public:
  void clear_stride();
  private:
  int32_t _internal_stride(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_stride() const;
  void _internal_add_stride(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_stride();
  public:
  int32_t stride(int index) const;
  void set_stride(int index, int32_t value);
  void add_stride(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      stride() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_stride();

  // repeated int32 window = 4;
  int window_size() const;
  private:
  int _internal_window_size() const;
  public:
  void clear_window();
  private:
  int32_t _internal_window(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_window() const;
  void _internal_add_window(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_window();
  public:
  int32_t window(int index) const;
  void set_window(int index, int32_t value);
  void add_window(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      window() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_window();

  // required .sapeon.simulator.SPLayer.SPSamplingMode mode = 1;
  bool has_mode() const;
  private:
  bool _internal_has_mode() const;
  public:
  void clear_mode();
  ::sapeon::simulator::SPLayer_SPSamplingMode mode() const;
  void set_mode(::sapeon::simulator::SPLayer_SPSamplingMode value);
  private:
  ::sapeon::simulator::SPLayer_SPSamplingMode _internal_mode() const;
  void _internal_set_mode(::sapeon::simulator::SPLayer_SPSamplingMode value);
  public:

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer.SPSamplingDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > padding_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > stride_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > window_;
    int mode_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPLayer_SPEWAddDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer.SPEWAddDesc) */ {
 public:
  inline SPLayer_SPEWAddDesc() : SPLayer_SPEWAddDesc(nullptr) {}
  ~SPLayer_SPEWAddDesc() override;
  explicit PROTOBUF_CONSTEXPR SPLayer_SPEWAddDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer_SPEWAddDesc(const SPLayer_SPEWAddDesc& from);
  SPLayer_SPEWAddDesc(SPLayer_SPEWAddDesc&& from) noexcept
    : SPLayer_SPEWAddDesc() {
    *this = ::std::move(from);
  }

  inline SPLayer_SPEWAddDesc& operator=(const SPLayer_SPEWAddDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer_SPEWAddDesc& operator=(SPLayer_SPEWAddDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer_SPEWAddDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer_SPEWAddDesc* internal_default_instance() {
    return reinterpret_cast<const SPLayer_SPEWAddDesc*>(
               &_SPLayer_SPEWAddDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SPLayer_SPEWAddDesc& a, SPLayer_SPEWAddDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer_SPEWAddDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer_SPEWAddDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer_SPEWAddDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer_SPEWAddDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer_SPEWAddDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer_SPEWAddDesc& from) {
    SPLayer_SPEWAddDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer_SPEWAddDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer.SPEWAddDesc";
  }
  protected:
  explicit SPLayer_SPEWAddDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaleFieldNumber = 1,
  };
  // repeated float scale = 1;
  int scale_size() const;
  private:
  int _internal_scale_size() const;
  public:
  void clear_scale();
  private:
  float _internal_scale(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_scale() const;
  void _internal_add_scale(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_scale();
  public:
  float scale(int index) const;
  void set_scale(int index, float value);
  void add_scale(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      scale() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_scale();

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer.SPEWAddDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPLayer_SPEWMulDesc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer.SPEWMulDesc) */ {
 public:
  inline SPLayer_SPEWMulDesc() : SPLayer_SPEWMulDesc(nullptr) {}
  ~SPLayer_SPEWMulDesc() override;
  explicit PROTOBUF_CONSTEXPR SPLayer_SPEWMulDesc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer_SPEWMulDesc(const SPLayer_SPEWMulDesc& from);
  SPLayer_SPEWMulDesc(SPLayer_SPEWMulDesc&& from) noexcept
    : SPLayer_SPEWMulDesc() {
    *this = ::std::move(from);
  }

  inline SPLayer_SPEWMulDesc& operator=(const SPLayer_SPEWMulDesc& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer_SPEWMulDesc& operator=(SPLayer_SPEWMulDesc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer_SPEWMulDesc& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer_SPEWMulDesc* internal_default_instance() {
    return reinterpret_cast<const SPLayer_SPEWMulDesc*>(
               &_SPLayer_SPEWMulDesc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SPLayer_SPEWMulDesc& a, SPLayer_SPEWMulDesc& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer_SPEWMulDesc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer_SPEWMulDesc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer_SPEWMulDesc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer_SPEWMulDesc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer_SPEWMulDesc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer_SPEWMulDesc& from) {
    SPLayer_SPEWMulDesc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer_SPEWMulDesc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer.SPEWMulDesc";
  }
  protected:
  explicit SPLayer_SPEWMulDesc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScaleFieldNumber = 1,
  };
  // repeated float scale = 1;
  int scale_size() const;
  private:
  int _internal_scale_size() const;
  public:
  void clear_scale();
  private:
  float _internal_scale(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_scale() const;
  void _internal_add_scale(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_scale();
  public:
  float scale(int index) const;
  void set_scale(int index, float value);
  void add_scale(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      scale() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_scale();

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer.SPEWMulDesc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > scale_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPLayer_SPTensor final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer.SPTensor) */ {
 public:
  inline SPLayer_SPTensor() : SPLayer_SPTensor(nullptr) {}
  ~SPLayer_SPTensor() override;
  explicit PROTOBUF_CONSTEXPR SPLayer_SPTensor(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer_SPTensor(const SPLayer_SPTensor& from);
  SPLayer_SPTensor(SPLayer_SPTensor&& from) noexcept
    : SPLayer_SPTensor() {
    *this = ::std::move(from);
  }

  inline SPLayer_SPTensor& operator=(const SPLayer_SPTensor& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer_SPTensor& operator=(SPLayer_SPTensor&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer_SPTensor& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer_SPTensor* internal_default_instance() {
    return reinterpret_cast<const SPLayer_SPTensor*>(
               &_SPLayer_SPTensor_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SPLayer_SPTensor& a, SPLayer_SPTensor& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer_SPTensor* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer_SPTensor* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer_SPTensor* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer_SPTensor>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer_SPTensor& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer_SPTensor& from) {
    SPLayer_SPTensor::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer_SPTensor* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer.SPTensor";
  }
  protected:
  explicit SPLayer_SPTensor(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDimsFieldNumber = 3,
    kFvalFieldNumber = 4,
    kBvalFieldNumber = 5,
    kDtypeFieldNumber = 1,
    kFormatFieldNumber = 2,
    kPtrFieldNumber = 7,
    kSizeFieldNumber = 6,
  };
  // repeated int32 dims = 3;
  int dims_size() const;
  private:
  int _internal_dims_size() const;
  public:
  void clear_dims();
  private:
  int32_t _internal_dims(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_dims() const;
  void _internal_add_dims(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_dims();
  public:
  int32_t dims(int index) const;
  void set_dims(int index, int32_t value);
  void add_dims(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      dims() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_dims();

  // repeated float fval = 4;
  int fval_size() const;
  private:
  int _internal_fval_size() const;
  public:
  void clear_fval();
  private:
  float _internal_fval(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_fval() const;
  void _internal_add_fval(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_fval();
  public:
  float fval(int index) const;
  void set_fval(int index, float value);
  void add_fval(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      fval() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_fval();

  // repeated int32 bval = 5 [packed = true];
  int bval_size() const;
  private:
  int _internal_bval_size() const;
  public:
  void clear_bval();
  private:
  int32_t _internal_bval(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_bval() const;
  void _internal_add_bval(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_bval();
  public:
  int32_t bval(int index) const;
  void set_bval(int index, int32_t value);
  void add_bval(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      bval() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_bval();

  // required .sapeon.simulator.SPLayer.SPDataType dtype = 1;
  bool has_dtype() const;
  private:
  bool _internal_has_dtype() const;
  public:
  void clear_dtype();
  ::sapeon::simulator::SPLayer_SPDataType dtype() const;
  void set_dtype(::sapeon::simulator::SPLayer_SPDataType value);
  private:
  ::sapeon::simulator::SPLayer_SPDataType _internal_dtype() const;
  void _internal_set_dtype(::sapeon::simulator::SPLayer_SPDataType value);
  public:

  // required .sapeon.simulator.SPLayer.SPTensorFormat format = 2;
  bool has_format() const;
  private:
  bool _internal_has_format() const;
  public:
  void clear_format();
  ::sapeon::simulator::SPLayer_SPTensorFormat format() const;
  void set_format(::sapeon::simulator::SPLayer_SPTensorFormat value);
  private:
  ::sapeon::simulator::SPLayer_SPTensorFormat _internal_format() const;
  void _internal_set_format(::sapeon::simulator::SPLayer_SPTensorFormat value);
  public:

  // optional int64 ptr = 7;
  bool has_ptr() const;
  private:
  bool _internal_has_ptr() const;
  public:
  void clear_ptr();
  int64_t ptr() const;
  void set_ptr(int64_t value);
  private:
  int64_t _internal_ptr() const;
  void _internal_set_ptr(int64_t value);
  public:

  // optional int32 size = 6;
  bool has_size() const;
  private:
  bool _internal_has_size() const;
  public:
  void clear_size();
  int32_t size() const;
  void set_size(int32_t value);
  private:
  int32_t _internal_size() const;
  void _internal_set_size(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer.SPTensor)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > dims_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > fval_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > bval_;
    mutable std::atomic<int> _bval_cached_byte_size_;
    int dtype_;
    int format_;
    int64_t ptr_;
    int32_t size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPLayer_Attribute final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer.Attribute) */ {
 public:
  inline SPLayer_Attribute() : SPLayer_Attribute(nullptr) {}
  ~SPLayer_Attribute() override;
  explicit PROTOBUF_CONSTEXPR SPLayer_Attribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer_Attribute(const SPLayer_Attribute& from);
  SPLayer_Attribute(SPLayer_Attribute&& from) noexcept
    : SPLayer_Attribute() {
    *this = ::std::move(from);
  }

  inline SPLayer_Attribute& operator=(const SPLayer_Attribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer_Attribute& operator=(SPLayer_Attribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer_Attribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer_Attribute* internal_default_instance() {
    return reinterpret_cast<const SPLayer_Attribute*>(
               &_SPLayer_Attribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(SPLayer_Attribute& a, SPLayer_Attribute& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer_Attribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer_Attribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer_Attribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer_Attribute>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer_Attribute& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer_Attribute& from) {
    SPLayer_Attribute::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer_Attribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer.Attribute";
  }
  protected:
  explicit SPLayer_Attribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SPLayer_Attribute_AttributeType AttributeType;
  static constexpr AttributeType UNDEFINED =
    SPLayer_Attribute_AttributeType_UNDEFINED;
  static constexpr AttributeType FLOAT =
    SPLayer_Attribute_AttributeType_FLOAT;
  static constexpr AttributeType INT =
    SPLayer_Attribute_AttributeType_INT;
  static constexpr AttributeType STRING =
    SPLayer_Attribute_AttributeType_STRING;
  static constexpr AttributeType FLOATS =
    SPLayer_Attribute_AttributeType_FLOATS;
  static constexpr AttributeType INTS =
    SPLayer_Attribute_AttributeType_INTS;
  static constexpr AttributeType STRINGS =
    SPLayer_Attribute_AttributeType_STRINGS;
  static inline bool AttributeType_IsValid(int value) {
    return SPLayer_Attribute_AttributeType_IsValid(value);
  }
  static constexpr AttributeType AttributeType_MIN =
    SPLayer_Attribute_AttributeType_AttributeType_MIN;
  static constexpr AttributeType AttributeType_MAX =
    SPLayer_Attribute_AttributeType_AttributeType_MAX;
  static constexpr int AttributeType_ARRAYSIZE =
    SPLayer_Attribute_AttributeType_AttributeType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  AttributeType_descriptor() {
    return SPLayer_Attribute_AttributeType_descriptor();
  }
  template<typename T>
  static inline const std::string& AttributeType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, AttributeType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function AttributeType_Name.");
    return SPLayer_Attribute_AttributeType_Name(enum_t_value);
  }
  static inline bool AttributeType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      AttributeType* value) {
    return SPLayer_Attribute_AttributeType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kFloatsFieldNumber = 7,
    kIntsFieldNumber = 8,
    kStringsFieldNumber = 9,
    kSFieldNumber = 4,
    kNameFieldNumber = 21,
    kIFieldNumber = 3,
    kFFieldNumber = 2,
    kTypeFieldNumber = 20,
  };
  // repeated float floats = 7;
  int floats_size() const;
  private:
  int _internal_floats_size() const;
  public:
  void clear_floats();
  private:
  float _internal_floats(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_floats() const;
  void _internal_add_floats(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_floats();
  public:
  float floats(int index) const;
  void set_floats(int index, float value);
  void add_floats(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      floats() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_floats();

  // repeated int64 ints = 8;
  int ints_size() const;
  private:
  int _internal_ints_size() const;
  public:
  void clear_ints();
  private:
  int64_t _internal_ints(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      _internal_ints() const;
  void _internal_add_ints(int64_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      _internal_mutable_ints();
  public:
  int64_t ints(int index) const;
  void set_ints(int index, int64_t value);
  void add_ints(int64_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
      ints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
      mutable_ints();

  // repeated bytes strings = 9;
  int strings_size() const;
  private:
  int _internal_strings_size() const;
  public:
  void clear_strings();
  const std::string& strings(int index) const;
  std::string* mutable_strings(int index);
  void set_strings(int index, const std::string& value);
  void set_strings(int index, std::string&& value);
  void set_strings(int index, const char* value);
  void set_strings(int index, const void* value, size_t size);
  std::string* add_strings();
  void add_strings(const std::string& value);
  void add_strings(std::string&& value);
  void add_strings(const char* value);
  void add_strings(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& strings() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_strings();
  private:
  const std::string& _internal_strings(int index) const;
  std::string* _internal_add_strings();
  public:

  // optional bytes s = 4;
  bool has_s() const;
  private:
  bool _internal_has_s() const;
  public:
  void clear_s();
  const std::string& s() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_s(ArgT0&& arg0, ArgT... args);
  std::string* mutable_s();
  PROTOBUF_NODISCARD std::string* release_s();
  void set_allocated_s(std::string* s);
  private:
  const std::string& _internal_s() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_s(const std::string& value);
  std::string* _internal_mutable_s();
  public:

  // optional string name = 21;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional int64 i = 3;
  bool has_i() const;
  private:
  bool _internal_has_i() const;
  public:
  void clear_i();
  int64_t i() const;
  void set_i(int64_t value);
  private:
  int64_t _internal_i() const;
  void _internal_set_i(int64_t value);
  public:

  // optional float f = 2;
  bool has_f() const;
  private:
  bool _internal_has_f() const;
  public:
  void clear_f();
  float f() const;
  void set_f(float value);
  private:
  float _internal_f() const;
  void _internal_set_f(float value);
  public:

  // optional .sapeon.simulator.SPLayer.Attribute.AttributeType type = 20;
  bool has_type() const;
  private:
  bool _internal_has_type() const;
  public:
  void clear_type();
  ::sapeon::simulator::SPLayer_Attribute_AttributeType type() const;
  void set_type(::sapeon::simulator::SPLayer_Attribute_AttributeType value);
  private:
  ::sapeon::simulator::SPLayer_Attribute_AttributeType _internal_type() const;
  void _internal_set_type(::sapeon::simulator::SPLayer_Attribute_AttributeType value);
  public:

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer.Attribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > floats_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t > ints_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> strings_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr s_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    int64_t i_;
    float f_;
    int type_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPLayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPLayer) */ {
 public:
  inline SPLayer() : SPLayer(nullptr) {}
  ~SPLayer() override;
  explicit PROTOBUF_CONSTEXPR SPLayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPLayer(const SPLayer& from);
  SPLayer(SPLayer&& from) noexcept
    : SPLayer() {
    *this = ::std::move(from);
  }

  inline SPLayer& operator=(const SPLayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPLayer& operator=(SPLayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPLayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPLayer* internal_default_instance() {
    return reinterpret_cast<const SPLayer*>(
               &_SPLayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(SPLayer& a, SPLayer& b) {
    a.Swap(&b);
  }
  inline void Swap(SPLayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPLayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPLayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPLayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPLayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPLayer& from) {
    SPLayer::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPLayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPLayer";
  }
  protected:
  explicit SPLayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SPLayer_SPConvolutionDesc SPConvolutionDesc;
  typedef SPLayer_SPSamplingDesc SPSamplingDesc;
  typedef SPLayer_SPEWAddDesc SPEWAddDesc;
  typedef SPLayer_SPEWMulDesc SPEWMulDesc;
  typedef SPLayer_SPTensor SPTensor;
  typedef SPLayer_Attribute Attribute;

  typedef SPLayer_SPActivationMode SPActivationMode;
  static constexpr SPActivationMode SP_ACTIVATION_SIGMOID =
    SPLayer_SPActivationMode_SP_ACTIVATION_SIGMOID;
  static constexpr SPActivationMode SP_ACTIVATION_RELU =
    SPLayer_SPActivationMode_SP_ACTIVATION_RELU;
  static constexpr SPActivationMode SP_ACTIVATION_LEAKY_RELU =
    SPLayer_SPActivationMode_SP_ACTIVATION_LEAKY_RELU;
  static constexpr SPActivationMode SP_ACTIVATION_PRELU =
    SPLayer_SPActivationMode_SP_ACTIVATION_PRELU;
  static constexpr SPActivationMode SP_ACTIVATION_TANH =
    SPLayer_SPActivationMode_SP_ACTIVATION_TANH;
  static constexpr SPActivationMode SP_ACTIVATION_IDENTITY =
    SPLayer_SPActivationMode_SP_ACTIVATION_IDENTITY;
  static constexpr SPActivationMode SP_ACTIVATION_MISH =
    SPLayer_SPActivationMode_SP_ACTIVATION_MISH;
  static constexpr SPActivationMode SP_ACTIVATION_RELU6 =
    SPLayer_SPActivationMode_SP_ACTIVATION_RELU6;
  static constexpr SPActivationMode SP_ACTIVATION_SWISH =
    SPLayer_SPActivationMode_SP_ACTIVATION_SWISH;
  static inline bool SPActivationMode_IsValid(int value) {
    return SPLayer_SPActivationMode_IsValid(value);
  }
  static constexpr SPActivationMode SPActivationMode_MIN =
    SPLayer_SPActivationMode_SPActivationMode_MIN;
  static constexpr SPActivationMode SPActivationMode_MAX =
    SPLayer_SPActivationMode_SPActivationMode_MAX;
  static constexpr int SPActivationMode_ARRAYSIZE =
    SPLayer_SPActivationMode_SPActivationMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SPActivationMode_descriptor() {
    return SPLayer_SPActivationMode_descriptor();
  }
  template<typename T>
  static inline const std::string& SPActivationMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SPActivationMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SPActivationMode_Name.");
    return SPLayer_SPActivationMode_Name(enum_t_value);
  }
  static inline bool SPActivationMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SPActivationMode* value) {
    return SPLayer_SPActivationMode_Parse(name, value);
  }

  typedef SPLayer_SPSamplingMode SPSamplingMode;
  static constexpr SPSamplingMode SP_POOLING_MAX =
    SPLayer_SPSamplingMode_SP_POOLING_MAX;
  static constexpr SPSamplingMode SP_POOLING_GLOBAL_AVERAGE =
    SPLayer_SPSamplingMode_SP_POOLING_GLOBAL_AVERAGE;
  static constexpr SPSamplingMode SP_POOLING_LOCAL_AVERAGE =
    SPLayer_SPSamplingMode_SP_POOLING_LOCAL_AVERAGE;
  static constexpr SPSamplingMode SP_POOLING_REORG =
    SPLayer_SPSamplingMode_SP_POOLING_REORG;
  static constexpr SPSamplingMode SP_POOLING_UPSAMPLE =
    SPLayer_SPSamplingMode_SP_POOLING_UPSAMPLE;
  static constexpr SPSamplingMode SP_POOLING_PIXELSHUFFLE =
    SPLayer_SPSamplingMode_SP_POOLING_PIXELSHUFFLE;
  static inline bool SPSamplingMode_IsValid(int value) {
    return SPLayer_SPSamplingMode_IsValid(value);
  }
  static constexpr SPSamplingMode SPSamplingMode_MIN =
    SPLayer_SPSamplingMode_SPSamplingMode_MIN;
  static constexpr SPSamplingMode SPSamplingMode_MAX =
    SPLayer_SPSamplingMode_SPSamplingMode_MAX;
  static constexpr int SPSamplingMode_ARRAYSIZE =
    SPLayer_SPSamplingMode_SPSamplingMode_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SPSamplingMode_descriptor() {
    return SPLayer_SPSamplingMode_descriptor();
  }
  template<typename T>
  static inline const std::string& SPSamplingMode_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SPSamplingMode>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SPSamplingMode_Name.");
    return SPLayer_SPSamplingMode_Name(enum_t_value);
  }
  static inline bool SPSamplingMode_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SPSamplingMode* value) {
    return SPLayer_SPSamplingMode_Parse(name, value);
  }

  typedef SPLayer_SPDataType SPDataType;
  static constexpr SPDataType SP_DATA_FLOAT =
    SPLayer_SPDataType_SP_DATA_FLOAT;
  static constexpr SPDataType SP_DATA_DOUBLE =
    SPLayer_SPDataType_SP_DATA_DOUBLE;
  static constexpr SPDataType SP_DATA_HALF =
    SPLayer_SPDataType_SP_DATA_HALF;
  static constexpr SPDataType SP_DATA_UINT8 =
    SPLayer_SPDataType_SP_DATA_UINT8;
  static constexpr SPDataType SP_DATA_SINT8 =
    SPLayer_SPDataType_SP_DATA_SINT8;
  static constexpr SPDataType SP_DATA_SINT16 =
    SPLayer_SPDataType_SP_DATA_SINT16;
  static inline bool SPDataType_IsValid(int value) {
    return SPLayer_SPDataType_IsValid(value);
  }
  static constexpr SPDataType SPDataType_MIN =
    SPLayer_SPDataType_SPDataType_MIN;
  static constexpr SPDataType SPDataType_MAX =
    SPLayer_SPDataType_SPDataType_MAX;
  static constexpr int SPDataType_ARRAYSIZE =
    SPLayer_SPDataType_SPDataType_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SPDataType_descriptor() {
    return SPLayer_SPDataType_descriptor();
  }
  template<typename T>
  static inline const std::string& SPDataType_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SPDataType>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SPDataType_Name.");
    return SPLayer_SPDataType_Name(enum_t_value);
  }
  static inline bool SPDataType_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SPDataType* value) {
    return SPLayer_SPDataType_Parse(name, value);
  }

  typedef SPLayer_SPTensorFormat SPTensorFormat;
  static constexpr SPTensorFormat SP_FORMAT_NCHW =
    SPLayer_SPTensorFormat_SP_FORMAT_NCHW;
  static constexpr SPTensorFormat SP_FORMAT_NHWC =
    SPLayer_SPTensorFormat_SP_FORMAT_NHWC;
  static constexpr SPTensorFormat SP_FORMAT_NWHC =
    SPLayer_SPTensorFormat_SP_FORMAT_NWHC;
  static constexpr SPTensorFormat SP_FORMAT_VECTOR =
    SPLayer_SPTensorFormat_SP_FORMAT_VECTOR;
  static inline bool SPTensorFormat_IsValid(int value) {
    return SPLayer_SPTensorFormat_IsValid(value);
  }
  static constexpr SPTensorFormat SPTensorFormat_MIN =
    SPLayer_SPTensorFormat_SPTensorFormat_MIN;
  static constexpr SPTensorFormat SPTensorFormat_MAX =
    SPLayer_SPTensorFormat_SPTensorFormat_MAX;
  static constexpr int SPTensorFormat_ARRAYSIZE =
    SPLayer_SPTensorFormat_SPTensorFormat_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  SPTensorFormat_descriptor() {
    return SPLayer_SPTensorFormat_descriptor();
  }
  template<typename T>
  static inline const std::string& SPTensorFormat_Name(T enum_t_value) {
    static_assert(::std::is_same<T, SPTensorFormat>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function SPTensorFormat_Name.");
    return SPLayer_SPTensorFormat_Name(enum_t_value);
  }
  static inline bool SPTensorFormat_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      SPTensorFormat* value) {
    return SPLayer_SPTensorFormat_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 3,
    kPredsFieldNumber = 4,
    kSuccsFieldNumber = 5,
    kInputFieldNumber = 6,
    kInputThresholdFieldNumber = 13,
    kFilterThresholdFieldNumber = 15,
    kAttributesFieldNumber = 31,
    kNameFieldNumber = 2,
    kOutputFieldNumber = 7,
    kFilterFieldNumber = 8,
    kBiasFieldNumber = 9,
    kScaleFieldNumber = 10,
    kMeanFieldNumber = 11,
    kVarianceFieldNumber = 12,
    kConvdescFieldNumber = 20,
    kSamplingdescFieldNumber = 21,
    kEwadddescFieldNumber = 22,
    kEwmuldescFieldNumber = 23,
    kIdFieldNumber = 1,
    kOutputThresholdFieldNumber = 14,
    kEpsilonFieldNumber = 16,
    kActivationFieldNumber = 30,
  };
  // repeated string type = 3;
  int type_size() const;
  private:
  int _internal_type_size() const;
  public:
  void clear_type();
  const std::string& type(int index) const;
  std::string* mutable_type(int index);
  void set_type(int index, const std::string& value);
  void set_type(int index, std::string&& value);
  void set_type(int index, const char* value);
  void set_type(int index, const char* value, size_t size);
  std::string* add_type();
  void add_type(const std::string& value);
  void add_type(std::string&& value);
  void add_type(const char* value);
  void add_type(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& type() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_type();
  private:
  const std::string& _internal_type(int index) const;
  std::string* _internal_add_type();
  public:

  // repeated int32 preds = 4;
  int preds_size() const;
  private:
  int _internal_preds_size() const;
  public:
  void clear_preds();
  private:
  int32_t _internal_preds(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_preds() const;
  void _internal_add_preds(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_preds();
  public:
  int32_t preds(int index) const;
  void set_preds(int index, int32_t value);
  void add_preds(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      preds() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_preds();

  // repeated int32 succs = 5;
  int succs_size() const;
  private:
  int _internal_succs_size() const;
  public:
  void clear_succs();
  private:
  int32_t _internal_succs(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_succs() const;
  void _internal_add_succs(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_succs();
  public:
  int32_t succs(int index) const;
  void set_succs(int index, int32_t value);
  void add_succs(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      succs() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_succs();

  // repeated .sapeon.simulator.SPLayer.SPTensor input = 6;
  int input_size() const;
  private:
  int _internal_input_size() const;
  public:
  void clear_input();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_input(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_SPTensor >*
      mutable_input();
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_input(int index) const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_add_input();
  public:
  const ::sapeon::simulator::SPLayer_SPTensor& input(int index) const;
  ::sapeon::simulator::SPLayer_SPTensor* add_input();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_SPTensor >&
      input() const;

  // repeated float input_threshold = 13;
  int input_threshold_size() const;
  private:
  int _internal_input_threshold_size() const;
  public:
  void clear_input_threshold();
  private:
  float _internal_input_threshold(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_input_threshold() const;
  void _internal_add_input_threshold(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_input_threshold();
  public:
  float input_threshold(int index) const;
  void set_input_threshold(int index, float value);
  void add_input_threshold(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      input_threshold() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_input_threshold();

  // repeated float filter_threshold = 15;
  int filter_threshold_size() const;
  private:
  int _internal_filter_threshold_size() const;
  public:
  void clear_filter_threshold();
  private:
  float _internal_filter_threshold(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      _internal_filter_threshold() const;
  void _internal_add_filter_threshold(float value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      _internal_mutable_filter_threshold();
  public:
  float filter_threshold(int index) const;
  void set_filter_threshold(int index, float value);
  void add_filter_threshold(float value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
      filter_threshold() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
      mutable_filter_threshold();

  // repeated .sapeon.simulator.SPLayer.Attribute attributes = 31;
  int attributes_size() const;
  private:
  int _internal_attributes_size() const;
  public:
  void clear_attributes();
  ::sapeon::simulator::SPLayer_Attribute* mutable_attributes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_Attribute >*
      mutable_attributes();
  private:
  const ::sapeon::simulator::SPLayer_Attribute& _internal_attributes(int index) const;
  ::sapeon::simulator::SPLayer_Attribute* _internal_add_attributes();
  public:
  const ::sapeon::simulator::SPLayer_Attribute& attributes(int index) const;
  ::sapeon::simulator::SPLayer_Attribute* add_attributes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_Attribute >&
      attributes() const;

  // optional string name = 2;
  bool has_name() const;
  private:
  bool _internal_has_name() const;
  public:
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // optional .sapeon.simulator.SPLayer.SPTensor output = 7;
  bool has_output() const;
  private:
  bool _internal_has_output() const;
  public:
  void clear_output();
  const ::sapeon::simulator::SPLayer_SPTensor& output() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPTensor* release_output();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_output();
  void set_allocated_output(::sapeon::simulator::SPLayer_SPTensor* output);
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_output() const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_mutable_output();
  public:
  void unsafe_arena_set_allocated_output(
      ::sapeon::simulator::SPLayer_SPTensor* output);
  ::sapeon::simulator::SPLayer_SPTensor* unsafe_arena_release_output();

  // optional .sapeon.simulator.SPLayer.SPTensor filter = 8;
  bool has_filter() const;
  private:
  bool _internal_has_filter() const;
  public:
  void clear_filter();
  const ::sapeon::simulator::SPLayer_SPTensor& filter() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPTensor* release_filter();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_filter();
  void set_allocated_filter(::sapeon::simulator::SPLayer_SPTensor* filter);
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_filter() const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_mutable_filter();
  public:
  void unsafe_arena_set_allocated_filter(
      ::sapeon::simulator::SPLayer_SPTensor* filter);
  ::sapeon::simulator::SPLayer_SPTensor* unsafe_arena_release_filter();

  // optional .sapeon.simulator.SPLayer.SPTensor bias = 9;
  bool has_bias() const;
  private:
  bool _internal_has_bias() const;
  public:
  void clear_bias();
  const ::sapeon::simulator::SPLayer_SPTensor& bias() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPTensor* release_bias();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_bias();
  void set_allocated_bias(::sapeon::simulator::SPLayer_SPTensor* bias);
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_bias() const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_mutable_bias();
  public:
  void unsafe_arena_set_allocated_bias(
      ::sapeon::simulator::SPLayer_SPTensor* bias);
  ::sapeon::simulator::SPLayer_SPTensor* unsafe_arena_release_bias();

  // optional .sapeon.simulator.SPLayer.SPTensor scale = 10;
  bool has_scale() const;
  private:
  bool _internal_has_scale() const;
  public:
  void clear_scale();
  const ::sapeon::simulator::SPLayer_SPTensor& scale() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPTensor* release_scale();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_scale();
  void set_allocated_scale(::sapeon::simulator::SPLayer_SPTensor* scale);
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_scale() const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_mutable_scale();
  public:
  void unsafe_arena_set_allocated_scale(
      ::sapeon::simulator::SPLayer_SPTensor* scale);
  ::sapeon::simulator::SPLayer_SPTensor* unsafe_arena_release_scale();

  // optional .sapeon.simulator.SPLayer.SPTensor mean = 11;
  bool has_mean() const;
  private:
  bool _internal_has_mean() const;
  public:
  void clear_mean();
  const ::sapeon::simulator::SPLayer_SPTensor& mean() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPTensor* release_mean();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_mean();
  void set_allocated_mean(::sapeon::simulator::SPLayer_SPTensor* mean);
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_mean() const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_mutable_mean();
  public:
  void unsafe_arena_set_allocated_mean(
      ::sapeon::simulator::SPLayer_SPTensor* mean);
  ::sapeon::simulator::SPLayer_SPTensor* unsafe_arena_release_mean();

  // optional .sapeon.simulator.SPLayer.SPTensor variance = 12;
  bool has_variance() const;
  private:
  bool _internal_has_variance() const;
  public:
  void clear_variance();
  const ::sapeon::simulator::SPLayer_SPTensor& variance() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPTensor* release_variance();
  ::sapeon::simulator::SPLayer_SPTensor* mutable_variance();
  void set_allocated_variance(::sapeon::simulator::SPLayer_SPTensor* variance);
  private:
  const ::sapeon::simulator::SPLayer_SPTensor& _internal_variance() const;
  ::sapeon::simulator::SPLayer_SPTensor* _internal_mutable_variance();
  public:
  void unsafe_arena_set_allocated_variance(
      ::sapeon::simulator::SPLayer_SPTensor* variance);
  ::sapeon::simulator::SPLayer_SPTensor* unsafe_arena_release_variance();

  // optional .sapeon.simulator.SPLayer.SPConvolutionDesc convdesc = 20;
  bool has_convdesc() const;
  private:
  bool _internal_has_convdesc() const;
  public:
  void clear_convdesc();
  const ::sapeon::simulator::SPLayer_SPConvolutionDesc& convdesc() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPConvolutionDesc* release_convdesc();
  ::sapeon::simulator::SPLayer_SPConvolutionDesc* mutable_convdesc();
  void set_allocated_convdesc(::sapeon::simulator::SPLayer_SPConvolutionDesc* convdesc);
  private:
  const ::sapeon::simulator::SPLayer_SPConvolutionDesc& _internal_convdesc() const;
  ::sapeon::simulator::SPLayer_SPConvolutionDesc* _internal_mutable_convdesc();
  public:
  void unsafe_arena_set_allocated_convdesc(
      ::sapeon::simulator::SPLayer_SPConvolutionDesc* convdesc);
  ::sapeon::simulator::SPLayer_SPConvolutionDesc* unsafe_arena_release_convdesc();

  // optional .sapeon.simulator.SPLayer.SPSamplingDesc samplingdesc = 21;
  bool has_samplingdesc() const;
  private:
  bool _internal_has_samplingdesc() const;
  public:
  void clear_samplingdesc();
  const ::sapeon::simulator::SPLayer_SPSamplingDesc& samplingdesc() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPSamplingDesc* release_samplingdesc();
  ::sapeon::simulator::SPLayer_SPSamplingDesc* mutable_samplingdesc();
  void set_allocated_samplingdesc(::sapeon::simulator::SPLayer_SPSamplingDesc* samplingdesc);
  private:
  const ::sapeon::simulator::SPLayer_SPSamplingDesc& _internal_samplingdesc() const;
  ::sapeon::simulator::SPLayer_SPSamplingDesc* _internal_mutable_samplingdesc();
  public:
  void unsafe_arena_set_allocated_samplingdesc(
      ::sapeon::simulator::SPLayer_SPSamplingDesc* samplingdesc);
  ::sapeon::simulator::SPLayer_SPSamplingDesc* unsafe_arena_release_samplingdesc();

  // optional .sapeon.simulator.SPLayer.SPEWAddDesc ewadddesc = 22;
  bool has_ewadddesc() const;
  private:
  bool _internal_has_ewadddesc() const;
  public:
  void clear_ewadddesc();
  const ::sapeon::simulator::SPLayer_SPEWAddDesc& ewadddesc() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPEWAddDesc* release_ewadddesc();
  ::sapeon::simulator::SPLayer_SPEWAddDesc* mutable_ewadddesc();
  void set_allocated_ewadddesc(::sapeon::simulator::SPLayer_SPEWAddDesc* ewadddesc);
  private:
  const ::sapeon::simulator::SPLayer_SPEWAddDesc& _internal_ewadddesc() const;
  ::sapeon::simulator::SPLayer_SPEWAddDesc* _internal_mutable_ewadddesc();
  public:
  void unsafe_arena_set_allocated_ewadddesc(
      ::sapeon::simulator::SPLayer_SPEWAddDesc* ewadddesc);
  ::sapeon::simulator::SPLayer_SPEWAddDesc* unsafe_arena_release_ewadddesc();

  // optional .sapeon.simulator.SPLayer.SPEWMulDesc ewmuldesc = 23;
  bool has_ewmuldesc() const;
  private:
  bool _internal_has_ewmuldesc() const;
  public:
  void clear_ewmuldesc();
  const ::sapeon::simulator::SPLayer_SPEWMulDesc& ewmuldesc() const;
  PROTOBUF_NODISCARD ::sapeon::simulator::SPLayer_SPEWMulDesc* release_ewmuldesc();
  ::sapeon::simulator::SPLayer_SPEWMulDesc* mutable_ewmuldesc();
  void set_allocated_ewmuldesc(::sapeon::simulator::SPLayer_SPEWMulDesc* ewmuldesc);
  private:
  const ::sapeon::simulator::SPLayer_SPEWMulDesc& _internal_ewmuldesc() const;
  ::sapeon::simulator::SPLayer_SPEWMulDesc* _internal_mutable_ewmuldesc();
  public:
  void unsafe_arena_set_allocated_ewmuldesc(
      ::sapeon::simulator::SPLayer_SPEWMulDesc* ewmuldesc);
  ::sapeon::simulator::SPLayer_SPEWMulDesc* unsafe_arena_release_ewmuldesc();

  // required int32 id = 1;
  bool has_id() const;
  private:
  bool _internal_has_id() const;
  public:
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // optional float output_threshold = 14;
  bool has_output_threshold() const;
  private:
  bool _internal_has_output_threshold() const;
  public:
  void clear_output_threshold();
  float output_threshold() const;
  void set_output_threshold(float value);
  private:
  float _internal_output_threshold() const;
  void _internal_set_output_threshold(float value);
  public:

  // optional float epsilon = 16;
  bool has_epsilon() const;
  private:
  bool _internal_has_epsilon() const;
  public:
  void clear_epsilon();
  float epsilon() const;
  void set_epsilon(float value);
  private:
  float _internal_epsilon() const;
  void _internal_set_epsilon(float value);
  public:

  // optional .sapeon.simulator.SPLayer.SPActivationMode activation = 30;
  bool has_activation() const;
  private:
  bool _internal_has_activation() const;
  public:
  void clear_activation();
  ::sapeon::simulator::SPLayer_SPActivationMode activation() const;
  void set_activation(::sapeon::simulator::SPLayer_SPActivationMode value);
  private:
  ::sapeon::simulator::SPLayer_SPActivationMode _internal_activation() const;
  void _internal_set_activation(::sapeon::simulator::SPLayer_SPActivationMode value);
  public:

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPLayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> type_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > preds_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > succs_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_SPTensor > input_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > input_threshold_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< float > filter_threshold_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_Attribute > attributes_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::sapeon::simulator::SPLayer_SPTensor* output_;
    ::sapeon::simulator::SPLayer_SPTensor* filter_;
    ::sapeon::simulator::SPLayer_SPTensor* bias_;
    ::sapeon::simulator::SPLayer_SPTensor* scale_;
    ::sapeon::simulator::SPLayer_SPTensor* mean_;
    ::sapeon::simulator::SPLayer_SPTensor* variance_;
    ::sapeon::simulator::SPLayer_SPConvolutionDesc* convdesc_;
    ::sapeon::simulator::SPLayer_SPSamplingDesc* samplingdesc_;
    ::sapeon::simulator::SPLayer_SPEWAddDesc* ewadddesc_;
    ::sapeon::simulator::SPLayer_SPEWMulDesc* ewmuldesc_;
    int32_t id_;
    float output_threshold_;
    float epsilon_;
    int activation_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// -------------------------------------------------------------------

class SPGraph final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:sapeon.simulator.SPGraph) */ {
 public:
  inline SPGraph() : SPGraph(nullptr) {}
  ~SPGraph() override;
  explicit PROTOBUF_CONSTEXPR SPGraph(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SPGraph(const SPGraph& from);
  SPGraph(SPGraph&& from) noexcept
    : SPGraph() {
    *this = ::std::move(from);
  }

  inline SPGraph& operator=(const SPGraph& from) {
    CopyFrom(from);
    return *this;
  }
  inline SPGraph& operator=(SPGraph&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>(::PROTOBUF_NAMESPACE_ID::UnknownFieldSet::default_instance);
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields<::PROTOBUF_NAMESPACE_ID::UnknownFieldSet>();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SPGraph& default_instance() {
    return *internal_default_instance();
  }
  static inline const SPGraph* internal_default_instance() {
    return reinterpret_cast<const SPGraph*>(
               &_SPGraph_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(SPGraph& a, SPGraph& b) {
    a.Swap(&b);
  }
  inline void Swap(SPGraph* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SPGraph* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SPGraph* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SPGraph>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SPGraph& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SPGraph& from) {
    SPGraph::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SPGraph* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "sapeon.simulator.SPGraph";
  }
  protected:
  explicit SPGraph(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLayerFieldNumber = 1,
    kInputLayersFieldNumber = 2,
    kOutputLayersFieldNumber = 3,
    kIsOptimizedFieldNumber = 5,
    kIrVersionFieldNumber = 4,
  };
  // repeated .sapeon.simulator.SPLayer layer = 1;
  int layer_size() const;
  private:
  int _internal_layer_size() const;
  public:
  void clear_layer();
  ::sapeon::simulator::SPLayer* mutable_layer(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer >*
      mutable_layer();
  private:
  const ::sapeon::simulator::SPLayer& _internal_layer(int index) const;
  ::sapeon::simulator::SPLayer* _internal_add_layer();
  public:
  const ::sapeon::simulator::SPLayer& layer(int index) const;
  ::sapeon::simulator::SPLayer* add_layer();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer >&
      layer() const;

  // repeated int32 input_layers = 2;
  int input_layers_size() const;
  private:
  int _internal_input_layers_size() const;
  public:
  void clear_input_layers();
  private:
  int32_t _internal_input_layers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_input_layers() const;
  void _internal_add_input_layers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_input_layers();
  public:
  int32_t input_layers(int index) const;
  void set_input_layers(int index, int32_t value);
  void add_input_layers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      input_layers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_input_layers();

  // repeated int32 output_layers = 3;
  int output_layers_size() const;
  private:
  int _internal_output_layers_size() const;
  public:
  void clear_output_layers();
  private:
  int32_t _internal_output_layers(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      _internal_output_layers() const;
  void _internal_add_output_layers(int32_t value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      _internal_mutable_output_layers();
  public:
  int32_t output_layers(int index) const;
  void set_output_layers(int index, int32_t value);
  void add_output_layers(int32_t value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
      output_layers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
      mutable_output_layers();

  // optional bool is_optimized = 5 [default = false];
  bool has_is_optimized() const;
  private:
  bool _internal_has_is_optimized() const;
  public:
  void clear_is_optimized();
  bool is_optimized() const;
  void set_is_optimized(bool value);
  private:
  bool _internal_is_optimized() const;
  void _internal_set_is_optimized(bool value);
  public:

  // optional int64 ir_version = 4 [default = 2];
  bool has_ir_version() const;
  private:
  bool _internal_has_ir_version() const;
  public:
  void clear_ir_version();
  int64_t ir_version() const;
  void set_ir_version(int64_t value);
  private:
  int64_t _internal_ir_version() const;
  void _internal_set_ir_version(int64_t value);
  public:

  // @@protoc_insertion_point(class_scope:sapeon.simulator.SPGraph)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer > layer_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > input_layers_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t > output_layers_;
    bool is_optimized_;
    int64_t ir_version_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_spear_2eproto_2ee8e8;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SPLayer_SPConvolutionDesc

// optional .sapeon.simulator.SPLayer.SPDataType dtype = 1;
inline bool SPLayer_SPConvolutionDesc::_internal_has_dtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SPLayer_SPConvolutionDesc::has_dtype() const {
  return _internal_has_dtype();
}
inline void SPLayer_SPConvolutionDesc::clear_dtype() {
  _impl_.dtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::sapeon::simulator::SPLayer_SPDataType SPLayer_SPConvolutionDesc::_internal_dtype() const {
  return static_cast< ::sapeon::simulator::SPLayer_SPDataType >(_impl_.dtype_);
}
inline ::sapeon::simulator::SPLayer_SPDataType SPLayer_SPConvolutionDesc::dtype() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPConvolutionDesc.dtype)
  return _internal_dtype();
}
inline void SPLayer_SPConvolutionDesc::_internal_set_dtype(::sapeon::simulator::SPLayer_SPDataType value) {
  assert(::sapeon::simulator::SPLayer_SPDataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dtype_ = value;
}
inline void SPLayer_SPConvolutionDesc::set_dtype(::sapeon::simulator::SPLayer_SPDataType value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPConvolutionDesc.dtype)
}

// repeated int32 padding = 2;
inline int SPLayer_SPConvolutionDesc::_internal_padding_size() const {
  return _impl_.padding_.size();
}
inline int SPLayer_SPConvolutionDesc::padding_size() const {
  return _internal_padding_size();
}
inline void SPLayer_SPConvolutionDesc::clear_padding() {
  _impl_.padding_.Clear();
}
inline int32_t SPLayer_SPConvolutionDesc::_internal_padding(int index) const {
  return _impl_.padding_.Get(index);
}
inline int32_t SPLayer_SPConvolutionDesc::padding(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPConvolutionDesc.padding)
  return _internal_padding(index);
}
inline void SPLayer_SPConvolutionDesc::set_padding(int index, int32_t value) {
  _impl_.padding_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPConvolutionDesc.padding)
}
inline void SPLayer_SPConvolutionDesc::_internal_add_padding(int32_t value) {
  _impl_.padding_.Add(value);
}
inline void SPLayer_SPConvolutionDesc::add_padding(int32_t value) {
  _internal_add_padding(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPConvolutionDesc.padding)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPConvolutionDesc::_internal_padding() const {
  return _impl_.padding_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPConvolutionDesc::padding() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPConvolutionDesc.padding)
  return _internal_padding();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPConvolutionDesc::_internal_mutable_padding() {
  return &_impl_.padding_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPConvolutionDesc::mutable_padding() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPConvolutionDesc.padding)
  return _internal_mutable_padding();
}

// repeated int32 stride = 3;
inline int SPLayer_SPConvolutionDesc::_internal_stride_size() const {
  return _impl_.stride_.size();
}
inline int SPLayer_SPConvolutionDesc::stride_size() const {
  return _internal_stride_size();
}
inline void SPLayer_SPConvolutionDesc::clear_stride() {
  _impl_.stride_.Clear();
}
inline int32_t SPLayer_SPConvolutionDesc::_internal_stride(int index) const {
  return _impl_.stride_.Get(index);
}
inline int32_t SPLayer_SPConvolutionDesc::stride(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPConvolutionDesc.stride)
  return _internal_stride(index);
}
inline void SPLayer_SPConvolutionDesc::set_stride(int index, int32_t value) {
  _impl_.stride_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPConvolutionDesc.stride)
}
inline void SPLayer_SPConvolutionDesc::_internal_add_stride(int32_t value) {
  _impl_.stride_.Add(value);
}
inline void SPLayer_SPConvolutionDesc::add_stride(int32_t value) {
  _internal_add_stride(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPConvolutionDesc.stride)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPConvolutionDesc::_internal_stride() const {
  return _impl_.stride_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPConvolutionDesc::stride() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPConvolutionDesc.stride)
  return _internal_stride();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPConvolutionDesc::_internal_mutable_stride() {
  return &_impl_.stride_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPConvolutionDesc::mutable_stride() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPConvolutionDesc.stride)
  return _internal_mutable_stride();
}

// repeated int32 dilation = 4;
inline int SPLayer_SPConvolutionDesc::_internal_dilation_size() const {
  return _impl_.dilation_.size();
}
inline int SPLayer_SPConvolutionDesc::dilation_size() const {
  return _internal_dilation_size();
}
inline void SPLayer_SPConvolutionDesc::clear_dilation() {
  _impl_.dilation_.Clear();
}
inline int32_t SPLayer_SPConvolutionDesc::_internal_dilation(int index) const {
  return _impl_.dilation_.Get(index);
}
inline int32_t SPLayer_SPConvolutionDesc::dilation(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPConvolutionDesc.dilation)
  return _internal_dilation(index);
}
inline void SPLayer_SPConvolutionDesc::set_dilation(int index, int32_t value) {
  _impl_.dilation_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPConvolutionDesc.dilation)
}
inline void SPLayer_SPConvolutionDesc::_internal_add_dilation(int32_t value) {
  _impl_.dilation_.Add(value);
}
inline void SPLayer_SPConvolutionDesc::add_dilation(int32_t value) {
  _internal_add_dilation(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPConvolutionDesc.dilation)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPConvolutionDesc::_internal_dilation() const {
  return _impl_.dilation_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPConvolutionDesc::dilation() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPConvolutionDesc.dilation)
  return _internal_dilation();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPConvolutionDesc::_internal_mutable_dilation() {
  return &_impl_.dilation_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPConvolutionDesc::mutable_dilation() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPConvolutionDesc.dilation)
  return _internal_mutable_dilation();
}

// required int32 groups = 5;
inline bool SPLayer_SPConvolutionDesc::_internal_has_groups() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SPLayer_SPConvolutionDesc::has_groups() const {
  return _internal_has_groups();
}
inline void SPLayer_SPConvolutionDesc::clear_groups() {
  _impl_.groups_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int32_t SPLayer_SPConvolutionDesc::_internal_groups() const {
  return _impl_.groups_;
}
inline int32_t SPLayer_SPConvolutionDesc::groups() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPConvolutionDesc.groups)
  return _internal_groups();
}
inline void SPLayer_SPConvolutionDesc::_internal_set_groups(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.groups_ = value;
}
inline void SPLayer_SPConvolutionDesc::set_groups(int32_t value) {
  _internal_set_groups(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPConvolutionDesc.groups)
}

// -------------------------------------------------------------------

// SPLayer_SPSamplingDesc

// required .sapeon.simulator.SPLayer.SPSamplingMode mode = 1;
inline bool SPLayer_SPSamplingDesc::_internal_has_mode() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SPLayer_SPSamplingDesc::has_mode() const {
  return _internal_has_mode();
}
inline void SPLayer_SPSamplingDesc::clear_mode() {
  _impl_.mode_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::sapeon::simulator::SPLayer_SPSamplingMode SPLayer_SPSamplingDesc::_internal_mode() const {
  return static_cast< ::sapeon::simulator::SPLayer_SPSamplingMode >(_impl_.mode_);
}
inline ::sapeon::simulator::SPLayer_SPSamplingMode SPLayer_SPSamplingDesc::mode() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPSamplingDesc.mode)
  return _internal_mode();
}
inline void SPLayer_SPSamplingDesc::_internal_set_mode(::sapeon::simulator::SPLayer_SPSamplingMode value) {
  assert(::sapeon::simulator::SPLayer_SPSamplingMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.mode_ = value;
}
inline void SPLayer_SPSamplingDesc::set_mode(::sapeon::simulator::SPLayer_SPSamplingMode value) {
  _internal_set_mode(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPSamplingDesc.mode)
}

// repeated int32 padding = 2;
inline int SPLayer_SPSamplingDesc::_internal_padding_size() const {
  return _impl_.padding_.size();
}
inline int SPLayer_SPSamplingDesc::padding_size() const {
  return _internal_padding_size();
}
inline void SPLayer_SPSamplingDesc::clear_padding() {
  _impl_.padding_.Clear();
}
inline int32_t SPLayer_SPSamplingDesc::_internal_padding(int index) const {
  return _impl_.padding_.Get(index);
}
inline int32_t SPLayer_SPSamplingDesc::padding(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPSamplingDesc.padding)
  return _internal_padding(index);
}
inline void SPLayer_SPSamplingDesc::set_padding(int index, int32_t value) {
  _impl_.padding_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPSamplingDesc.padding)
}
inline void SPLayer_SPSamplingDesc::_internal_add_padding(int32_t value) {
  _impl_.padding_.Add(value);
}
inline void SPLayer_SPSamplingDesc::add_padding(int32_t value) {
  _internal_add_padding(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPSamplingDesc.padding)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPSamplingDesc::_internal_padding() const {
  return _impl_.padding_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPSamplingDesc::padding() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPSamplingDesc.padding)
  return _internal_padding();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPSamplingDesc::_internal_mutable_padding() {
  return &_impl_.padding_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPSamplingDesc::mutable_padding() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPSamplingDesc.padding)
  return _internal_mutable_padding();
}

// repeated int32 stride = 3;
inline int SPLayer_SPSamplingDesc::_internal_stride_size() const {
  return _impl_.stride_.size();
}
inline int SPLayer_SPSamplingDesc::stride_size() const {
  return _internal_stride_size();
}
inline void SPLayer_SPSamplingDesc::clear_stride() {
  _impl_.stride_.Clear();
}
inline int32_t SPLayer_SPSamplingDesc::_internal_stride(int index) const {
  return _impl_.stride_.Get(index);
}
inline int32_t SPLayer_SPSamplingDesc::stride(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPSamplingDesc.stride)
  return _internal_stride(index);
}
inline void SPLayer_SPSamplingDesc::set_stride(int index, int32_t value) {
  _impl_.stride_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPSamplingDesc.stride)
}
inline void SPLayer_SPSamplingDesc::_internal_add_stride(int32_t value) {
  _impl_.stride_.Add(value);
}
inline void SPLayer_SPSamplingDesc::add_stride(int32_t value) {
  _internal_add_stride(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPSamplingDesc.stride)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPSamplingDesc::_internal_stride() const {
  return _impl_.stride_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPSamplingDesc::stride() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPSamplingDesc.stride)
  return _internal_stride();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPSamplingDesc::_internal_mutable_stride() {
  return &_impl_.stride_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPSamplingDesc::mutable_stride() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPSamplingDesc.stride)
  return _internal_mutable_stride();
}

// repeated int32 window = 4;
inline int SPLayer_SPSamplingDesc::_internal_window_size() const {
  return _impl_.window_.size();
}
inline int SPLayer_SPSamplingDesc::window_size() const {
  return _internal_window_size();
}
inline void SPLayer_SPSamplingDesc::clear_window() {
  _impl_.window_.Clear();
}
inline int32_t SPLayer_SPSamplingDesc::_internal_window(int index) const {
  return _impl_.window_.Get(index);
}
inline int32_t SPLayer_SPSamplingDesc::window(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPSamplingDesc.window)
  return _internal_window(index);
}
inline void SPLayer_SPSamplingDesc::set_window(int index, int32_t value) {
  _impl_.window_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPSamplingDesc.window)
}
inline void SPLayer_SPSamplingDesc::_internal_add_window(int32_t value) {
  _impl_.window_.Add(value);
}
inline void SPLayer_SPSamplingDesc::add_window(int32_t value) {
  _internal_add_window(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPSamplingDesc.window)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPSamplingDesc::_internal_window() const {
  return _impl_.window_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPSamplingDesc::window() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPSamplingDesc.window)
  return _internal_window();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPSamplingDesc::_internal_mutable_window() {
  return &_impl_.window_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPSamplingDesc::mutable_window() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPSamplingDesc.window)
  return _internal_mutable_window();
}

// -------------------------------------------------------------------

// SPLayer_SPEWAddDesc

// repeated float scale = 1;
inline int SPLayer_SPEWAddDesc::_internal_scale_size() const {
  return _impl_.scale_.size();
}
inline int SPLayer_SPEWAddDesc::scale_size() const {
  return _internal_scale_size();
}
inline void SPLayer_SPEWAddDesc::clear_scale() {
  _impl_.scale_.Clear();
}
inline float SPLayer_SPEWAddDesc::_internal_scale(int index) const {
  return _impl_.scale_.Get(index);
}
inline float SPLayer_SPEWAddDesc::scale(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPEWAddDesc.scale)
  return _internal_scale(index);
}
inline void SPLayer_SPEWAddDesc::set_scale(int index, float value) {
  _impl_.scale_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPEWAddDesc.scale)
}
inline void SPLayer_SPEWAddDesc::_internal_add_scale(float value) {
  _impl_.scale_.Add(value);
}
inline void SPLayer_SPEWAddDesc::add_scale(float value) {
  _internal_add_scale(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPEWAddDesc.scale)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_SPEWAddDesc::_internal_scale() const {
  return _impl_.scale_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_SPEWAddDesc::scale() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPEWAddDesc.scale)
  return _internal_scale();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_SPEWAddDesc::_internal_mutable_scale() {
  return &_impl_.scale_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_SPEWAddDesc::mutable_scale() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPEWAddDesc.scale)
  return _internal_mutable_scale();
}

// -------------------------------------------------------------------

// SPLayer_SPEWMulDesc

// repeated float scale = 1;
inline int SPLayer_SPEWMulDesc::_internal_scale_size() const {
  return _impl_.scale_.size();
}
inline int SPLayer_SPEWMulDesc::scale_size() const {
  return _internal_scale_size();
}
inline void SPLayer_SPEWMulDesc::clear_scale() {
  _impl_.scale_.Clear();
}
inline float SPLayer_SPEWMulDesc::_internal_scale(int index) const {
  return _impl_.scale_.Get(index);
}
inline float SPLayer_SPEWMulDesc::scale(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPEWMulDesc.scale)
  return _internal_scale(index);
}
inline void SPLayer_SPEWMulDesc::set_scale(int index, float value) {
  _impl_.scale_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPEWMulDesc.scale)
}
inline void SPLayer_SPEWMulDesc::_internal_add_scale(float value) {
  _impl_.scale_.Add(value);
}
inline void SPLayer_SPEWMulDesc::add_scale(float value) {
  _internal_add_scale(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPEWMulDesc.scale)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_SPEWMulDesc::_internal_scale() const {
  return _impl_.scale_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_SPEWMulDesc::scale() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPEWMulDesc.scale)
  return _internal_scale();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_SPEWMulDesc::_internal_mutable_scale() {
  return &_impl_.scale_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_SPEWMulDesc::mutable_scale() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPEWMulDesc.scale)
  return _internal_mutable_scale();
}

// -------------------------------------------------------------------

// SPLayer_SPTensor

// required .sapeon.simulator.SPLayer.SPDataType dtype = 1;
inline bool SPLayer_SPTensor::_internal_has_dtype() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SPLayer_SPTensor::has_dtype() const {
  return _internal_has_dtype();
}
inline void SPLayer_SPTensor::clear_dtype() {
  _impl_.dtype_ = 0;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline ::sapeon::simulator::SPLayer_SPDataType SPLayer_SPTensor::_internal_dtype() const {
  return static_cast< ::sapeon::simulator::SPLayer_SPDataType >(_impl_.dtype_);
}
inline ::sapeon::simulator::SPLayer_SPDataType SPLayer_SPTensor::dtype() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.dtype)
  return _internal_dtype();
}
inline void SPLayer_SPTensor::_internal_set_dtype(::sapeon::simulator::SPLayer_SPDataType value) {
  assert(::sapeon::simulator::SPLayer_SPDataType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.dtype_ = value;
}
inline void SPLayer_SPTensor::set_dtype(::sapeon::simulator::SPLayer_SPDataType value) {
  _internal_set_dtype(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.dtype)
}

// required .sapeon.simulator.SPLayer.SPTensorFormat format = 2;
inline bool SPLayer_SPTensor::_internal_has_format() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SPLayer_SPTensor::has_format() const {
  return _internal_has_format();
}
inline void SPLayer_SPTensor::clear_format() {
  _impl_.format_ = 0;
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline ::sapeon::simulator::SPLayer_SPTensorFormat SPLayer_SPTensor::_internal_format() const {
  return static_cast< ::sapeon::simulator::SPLayer_SPTensorFormat >(_impl_.format_);
}
inline ::sapeon::simulator::SPLayer_SPTensorFormat SPLayer_SPTensor::format() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.format)
  return _internal_format();
}
inline void SPLayer_SPTensor::_internal_set_format(::sapeon::simulator::SPLayer_SPTensorFormat value) {
  assert(::sapeon::simulator::SPLayer_SPTensorFormat_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.format_ = value;
}
inline void SPLayer_SPTensor::set_format(::sapeon::simulator::SPLayer_SPTensorFormat value) {
  _internal_set_format(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.format)
}

// repeated int32 dims = 3;
inline int SPLayer_SPTensor::_internal_dims_size() const {
  return _impl_.dims_.size();
}
inline int SPLayer_SPTensor::dims_size() const {
  return _internal_dims_size();
}
inline void SPLayer_SPTensor::clear_dims() {
  _impl_.dims_.Clear();
}
inline int32_t SPLayer_SPTensor::_internal_dims(int index) const {
  return _impl_.dims_.Get(index);
}
inline int32_t SPLayer_SPTensor::dims(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.dims)
  return _internal_dims(index);
}
inline void SPLayer_SPTensor::set_dims(int index, int32_t value) {
  _impl_.dims_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.dims)
}
inline void SPLayer_SPTensor::_internal_add_dims(int32_t value) {
  _impl_.dims_.Add(value);
}
inline void SPLayer_SPTensor::add_dims(int32_t value) {
  _internal_add_dims(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPTensor.dims)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPTensor::_internal_dims() const {
  return _impl_.dims_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPTensor::dims() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPTensor.dims)
  return _internal_dims();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPTensor::_internal_mutable_dims() {
  return &_impl_.dims_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPTensor::mutable_dims() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPTensor.dims)
  return _internal_mutable_dims();
}

// repeated float fval = 4;
inline int SPLayer_SPTensor::_internal_fval_size() const {
  return _impl_.fval_.size();
}
inline int SPLayer_SPTensor::fval_size() const {
  return _internal_fval_size();
}
inline void SPLayer_SPTensor::clear_fval() {
  _impl_.fval_.Clear();
}
inline float SPLayer_SPTensor::_internal_fval(int index) const {
  return _impl_.fval_.Get(index);
}
inline float SPLayer_SPTensor::fval(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.fval)
  return _internal_fval(index);
}
inline void SPLayer_SPTensor::set_fval(int index, float value) {
  _impl_.fval_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.fval)
}
inline void SPLayer_SPTensor::_internal_add_fval(float value) {
  _impl_.fval_.Add(value);
}
inline void SPLayer_SPTensor::add_fval(float value) {
  _internal_add_fval(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPTensor.fval)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_SPTensor::_internal_fval() const {
  return _impl_.fval_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_SPTensor::fval() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPTensor.fval)
  return _internal_fval();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_SPTensor::_internal_mutable_fval() {
  return &_impl_.fval_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_SPTensor::mutable_fval() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPTensor.fval)
  return _internal_mutable_fval();
}

// repeated int32 bval = 5 [packed = true];
inline int SPLayer_SPTensor::_internal_bval_size() const {
  return _impl_.bval_.size();
}
inline int SPLayer_SPTensor::bval_size() const {
  return _internal_bval_size();
}
inline void SPLayer_SPTensor::clear_bval() {
  _impl_.bval_.Clear();
}
inline int32_t SPLayer_SPTensor::_internal_bval(int index) const {
  return _impl_.bval_.Get(index);
}
inline int32_t SPLayer_SPTensor::bval(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.bval)
  return _internal_bval(index);
}
inline void SPLayer_SPTensor::set_bval(int index, int32_t value) {
  _impl_.bval_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.bval)
}
inline void SPLayer_SPTensor::_internal_add_bval(int32_t value) {
  _impl_.bval_.Add(value);
}
inline void SPLayer_SPTensor::add_bval(int32_t value) {
  _internal_add_bval(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.SPTensor.bval)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPTensor::_internal_bval() const {
  return _impl_.bval_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer_SPTensor::bval() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.SPTensor.bval)
  return _internal_bval();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPTensor::_internal_mutable_bval() {
  return &_impl_.bval_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer_SPTensor::mutable_bval() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.SPTensor.bval)
  return _internal_mutable_bval();
}

// optional int32 size = 6;
inline bool SPLayer_SPTensor::_internal_has_size() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SPLayer_SPTensor::has_size() const {
  return _internal_has_size();
}
inline void SPLayer_SPTensor::clear_size() {
  _impl_.size_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline int32_t SPLayer_SPTensor::_internal_size() const {
  return _impl_.size_;
}
inline int32_t SPLayer_SPTensor::size() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.size)
  return _internal_size();
}
inline void SPLayer_SPTensor::_internal_set_size(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.size_ = value;
}
inline void SPLayer_SPTensor::set_size(int32_t value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.size)
}

// optional int64 ptr = 7;
inline bool SPLayer_SPTensor::_internal_has_ptr() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SPLayer_SPTensor::has_ptr() const {
  return _internal_has_ptr();
}
inline void SPLayer_SPTensor::clear_ptr() {
  _impl_.ptr_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t SPLayer_SPTensor::_internal_ptr() const {
  return _impl_.ptr_;
}
inline int64_t SPLayer_SPTensor::ptr() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.SPTensor.ptr)
  return _internal_ptr();
}
inline void SPLayer_SPTensor::_internal_set_ptr(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.ptr_ = value;
}
inline void SPLayer_SPTensor::set_ptr(int64_t value) {
  _internal_set_ptr(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.SPTensor.ptr)
}

// -------------------------------------------------------------------

// SPLayer_Attribute

// optional string name = 21;
inline bool SPLayer_Attribute::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SPLayer_Attribute::has_name() const {
  return _internal_has_name();
}
inline void SPLayer_Attribute::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const std::string& SPLayer_Attribute::name() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SPLayer_Attribute::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000002u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.name)
}
inline std::string* SPLayer_Attribute::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.Attribute.name)
  return _s;
}
inline const std::string& SPLayer_Attribute::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SPLayer_Attribute::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SPLayer_Attribute::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000002u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SPLayer_Attribute::release_name() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.Attribute.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000002u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SPLayer_Attribute::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.Attribute.name)
}

// optional .sapeon.simulator.SPLayer.Attribute.AttributeType type = 20;
inline bool SPLayer_Attribute::_internal_has_type() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  return value;
}
inline bool SPLayer_Attribute::has_type() const {
  return _internal_has_type();
}
inline void SPLayer_Attribute::clear_type() {
  _impl_.type_ = 0;
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline ::sapeon::simulator::SPLayer_Attribute_AttributeType SPLayer_Attribute::_internal_type() const {
  return static_cast< ::sapeon::simulator::SPLayer_Attribute_AttributeType >(_impl_.type_);
}
inline ::sapeon::simulator::SPLayer_Attribute_AttributeType SPLayer_Attribute::type() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.type)
  return _internal_type();
}
inline void SPLayer_Attribute::_internal_set_type(::sapeon::simulator::SPLayer_Attribute_AttributeType value) {
  assert(::sapeon::simulator::SPLayer_Attribute_AttributeType_IsValid(value));
  _impl_._has_bits_[0] |= 0x00000010u;
  _impl_.type_ = value;
}
inline void SPLayer_Attribute::set_type(::sapeon::simulator::SPLayer_Attribute_AttributeType value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.type)
}

// optional float f = 2;
inline bool SPLayer_Attribute::_internal_has_f() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  return value;
}
inline bool SPLayer_Attribute::has_f() const {
  return _internal_has_f();
}
inline void SPLayer_Attribute::clear_f() {
  _impl_.f_ = 0;
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline float SPLayer_Attribute::_internal_f() const {
  return _impl_.f_;
}
inline float SPLayer_Attribute::f() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.f)
  return _internal_f();
}
inline void SPLayer_Attribute::_internal_set_f(float value) {
  _impl_._has_bits_[0] |= 0x00000008u;
  _impl_.f_ = value;
}
inline void SPLayer_Attribute::set_f(float value) {
  _internal_set_f(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.f)
}

// optional int64 i = 3;
inline bool SPLayer_Attribute::_internal_has_i() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  return value;
}
inline bool SPLayer_Attribute::has_i() const {
  return _internal_has_i();
}
inline void SPLayer_Attribute::clear_i() {
  _impl_.i_ = int64_t{0};
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline int64_t SPLayer_Attribute::_internal_i() const {
  return _impl_.i_;
}
inline int64_t SPLayer_Attribute::i() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.i)
  return _internal_i();
}
inline void SPLayer_Attribute::_internal_set_i(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000004u;
  _impl_.i_ = value;
}
inline void SPLayer_Attribute::set_i(int64_t value) {
  _internal_set_i(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.i)
}

// optional bytes s = 4;
inline bool SPLayer_Attribute::_internal_has_s() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SPLayer_Attribute::has_s() const {
  return _internal_has_s();
}
inline void SPLayer_Attribute::clear_s() {
  _impl_.s_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SPLayer_Attribute::s() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.s)
  return _internal_s();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SPLayer_Attribute::set_s(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.s_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.s)
}
inline std::string* SPLayer_Attribute::mutable_s() {
  std::string* _s = _internal_mutable_s();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.Attribute.s)
  return _s;
}
inline const std::string& SPLayer_Attribute::_internal_s() const {
  return _impl_.s_.Get();
}
inline void SPLayer_Attribute::_internal_set_s(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.s_.Set(value, GetArenaForAllocation());
}
inline std::string* SPLayer_Attribute::_internal_mutable_s() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.s_.Mutable(GetArenaForAllocation());
}
inline std::string* SPLayer_Attribute::release_s() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.Attribute.s)
  if (!_internal_has_s()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.s_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SPLayer_Attribute::set_allocated_s(std::string* s) {
  if (s != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.s_.SetAllocated(s, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.s_.IsDefault()) {
    _impl_.s_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.Attribute.s)
}

// repeated float floats = 7;
inline int SPLayer_Attribute::_internal_floats_size() const {
  return _impl_.floats_.size();
}
inline int SPLayer_Attribute::floats_size() const {
  return _internal_floats_size();
}
inline void SPLayer_Attribute::clear_floats() {
  _impl_.floats_.Clear();
}
inline float SPLayer_Attribute::_internal_floats(int index) const {
  return _impl_.floats_.Get(index);
}
inline float SPLayer_Attribute::floats(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.floats)
  return _internal_floats(index);
}
inline void SPLayer_Attribute::set_floats(int index, float value) {
  _impl_.floats_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.floats)
}
inline void SPLayer_Attribute::_internal_add_floats(float value) {
  _impl_.floats_.Add(value);
}
inline void SPLayer_Attribute::add_floats(float value) {
  _internal_add_floats(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.Attribute.floats)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_Attribute::_internal_floats() const {
  return _impl_.floats_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer_Attribute::floats() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.Attribute.floats)
  return _internal_floats();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_Attribute::_internal_mutable_floats() {
  return &_impl_.floats_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer_Attribute::mutable_floats() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.Attribute.floats)
  return _internal_mutable_floats();
}

// repeated int64 ints = 8;
inline int SPLayer_Attribute::_internal_ints_size() const {
  return _impl_.ints_.size();
}
inline int SPLayer_Attribute::ints_size() const {
  return _internal_ints_size();
}
inline void SPLayer_Attribute::clear_ints() {
  _impl_.ints_.Clear();
}
inline int64_t SPLayer_Attribute::_internal_ints(int index) const {
  return _impl_.ints_.Get(index);
}
inline int64_t SPLayer_Attribute::ints(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.ints)
  return _internal_ints(index);
}
inline void SPLayer_Attribute::set_ints(int index, int64_t value) {
  _impl_.ints_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.ints)
}
inline void SPLayer_Attribute::_internal_add_ints(int64_t value) {
  _impl_.ints_.Add(value);
}
inline void SPLayer_Attribute::add_ints(int64_t value) {
  _internal_add_ints(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.Attribute.ints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
SPLayer_Attribute::_internal_ints() const {
  return _impl_.ints_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >&
SPLayer_Attribute::ints() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.Attribute.ints)
  return _internal_ints();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
SPLayer_Attribute::_internal_mutable_ints() {
  return &_impl_.ints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int64_t >*
SPLayer_Attribute::mutable_ints() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.Attribute.ints)
  return _internal_mutable_ints();
}

// repeated bytes strings = 9;
inline int SPLayer_Attribute::_internal_strings_size() const {
  return _impl_.strings_.size();
}
inline int SPLayer_Attribute::strings_size() const {
  return _internal_strings_size();
}
inline void SPLayer_Attribute::clear_strings() {
  _impl_.strings_.Clear();
}
inline std::string* SPLayer_Attribute::add_strings() {
  std::string* _s = _internal_add_strings();
  // @@protoc_insertion_point(field_add_mutable:sapeon.simulator.SPLayer.Attribute.strings)
  return _s;
}
inline const std::string& SPLayer_Attribute::_internal_strings(int index) const {
  return _impl_.strings_.Get(index);
}
inline const std::string& SPLayer_Attribute::strings(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.Attribute.strings)
  return _internal_strings(index);
}
inline std::string* SPLayer_Attribute::mutable_strings(int index) {
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.Attribute.strings)
  return _impl_.strings_.Mutable(index);
}
inline void SPLayer_Attribute::set_strings(int index, const std::string& value) {
  _impl_.strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.strings)
}
inline void SPLayer_Attribute::set_strings(int index, std::string&& value) {
  _impl_.strings_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.Attribute.strings)
}
inline void SPLayer_Attribute::set_strings(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.strings_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sapeon.simulator.SPLayer.Attribute.strings)
}
inline void SPLayer_Attribute::set_strings(int index, const void* value, size_t size) {
  _impl_.strings_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sapeon.simulator.SPLayer.Attribute.strings)
}
inline std::string* SPLayer_Attribute::_internal_add_strings() {
  return _impl_.strings_.Add();
}
inline void SPLayer_Attribute::add_strings(const std::string& value) {
  _impl_.strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.Attribute.strings)
}
inline void SPLayer_Attribute::add_strings(std::string&& value) {
  _impl_.strings_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.Attribute.strings)
}
inline void SPLayer_Attribute::add_strings(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.strings_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sapeon.simulator.SPLayer.Attribute.strings)
}
inline void SPLayer_Attribute::add_strings(const void* value, size_t size) {
  _impl_.strings_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sapeon.simulator.SPLayer.Attribute.strings)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SPLayer_Attribute::strings() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.Attribute.strings)
  return _impl_.strings_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SPLayer_Attribute::mutable_strings() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.Attribute.strings)
  return &_impl_.strings_;
}

// -------------------------------------------------------------------

// SPLayer

// required int32 id = 1;
inline bool SPLayer::_internal_has_id() const {
  bool value = (_impl_._has_bits_[0] & 0x00000800u) != 0;
  return value;
}
inline bool SPLayer::has_id() const {
  return _internal_has_id();
}
inline void SPLayer::clear_id() {
  _impl_.id_ = 0;
  _impl_._has_bits_[0] &= ~0x00000800u;
}
inline int32_t SPLayer::_internal_id() const {
  return _impl_.id_;
}
inline int32_t SPLayer::id() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.id)
  return _internal_id();
}
inline void SPLayer::_internal_set_id(int32_t value) {
  _impl_._has_bits_[0] |= 0x00000800u;
  _impl_.id_ = value;
}
inline void SPLayer::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.id)
}

// optional string name = 2;
inline bool SPLayer::_internal_has_name() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SPLayer::has_name() const {
  return _internal_has_name();
}
inline void SPLayer::clear_name() {
  _impl_.name_.ClearToEmpty();
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const std::string& SPLayer::name() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SPLayer::set_name(ArgT0&& arg0, ArgT... args) {
 _impl_._has_bits_[0] |= 0x00000001u;
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.name)
}
inline std::string* SPLayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.name)
  return _s;
}
inline const std::string& SPLayer::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SPLayer::_internal_set_name(const std::string& value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SPLayer::_internal_mutable_name() {
  _impl_._has_bits_[0] |= 0x00000001u;
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SPLayer::release_name() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.name)
  if (!_internal_has_name()) {
    return nullptr;
  }
  _impl_._has_bits_[0] &= ~0x00000001u;
  auto* p = _impl_.name_.Release();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  return p;
}
inline void SPLayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.name)
}

// repeated string type = 3;
inline int SPLayer::_internal_type_size() const {
  return _impl_.type_.size();
}
inline int SPLayer::type_size() const {
  return _internal_type_size();
}
inline void SPLayer::clear_type() {
  _impl_.type_.Clear();
}
inline std::string* SPLayer::add_type() {
  std::string* _s = _internal_add_type();
  // @@protoc_insertion_point(field_add_mutable:sapeon.simulator.SPLayer.type)
  return _s;
}
inline const std::string& SPLayer::_internal_type(int index) const {
  return _impl_.type_.Get(index);
}
inline const std::string& SPLayer::type(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.type)
  return _internal_type(index);
}
inline std::string* SPLayer::mutable_type(int index) {
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.type)
  return _impl_.type_.Mutable(index);
}
inline void SPLayer::set_type(int index, const std::string& value) {
  _impl_.type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.type)
}
inline void SPLayer::set_type(int index, std::string&& value) {
  _impl_.type_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.type)
}
inline void SPLayer::set_type(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.type_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:sapeon.simulator.SPLayer.type)
}
inline void SPLayer::set_type(int index, const char* value, size_t size) {
  _impl_.type_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:sapeon.simulator.SPLayer.type)
}
inline std::string* SPLayer::_internal_add_type() {
  return _impl_.type_.Add();
}
inline void SPLayer::add_type(const std::string& value) {
  _impl_.type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.type)
}
inline void SPLayer::add_type(std::string&& value) {
  _impl_.type_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.type)
}
inline void SPLayer::add_type(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _impl_.type_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:sapeon.simulator.SPLayer.type)
}
inline void SPLayer::add_type(const char* value, size_t size) {
  _impl_.type_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:sapeon.simulator.SPLayer.type)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
SPLayer::type() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.type)
  return _impl_.type_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
SPLayer::mutable_type() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.type)
  return &_impl_.type_;
}

// repeated int32 preds = 4;
inline int SPLayer::_internal_preds_size() const {
  return _impl_.preds_.size();
}
inline int SPLayer::preds_size() const {
  return _internal_preds_size();
}
inline void SPLayer::clear_preds() {
  _impl_.preds_.Clear();
}
inline int32_t SPLayer::_internal_preds(int index) const {
  return _impl_.preds_.Get(index);
}
inline int32_t SPLayer::preds(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.preds)
  return _internal_preds(index);
}
inline void SPLayer::set_preds(int index, int32_t value) {
  _impl_.preds_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.preds)
}
inline void SPLayer::_internal_add_preds(int32_t value) {
  _impl_.preds_.Add(value);
}
inline void SPLayer::add_preds(int32_t value) {
  _internal_add_preds(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.preds)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer::_internal_preds() const {
  return _impl_.preds_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer::preds() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.preds)
  return _internal_preds();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer::_internal_mutable_preds() {
  return &_impl_.preds_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer::mutable_preds() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.preds)
  return _internal_mutable_preds();
}

// repeated int32 succs = 5;
inline int SPLayer::_internal_succs_size() const {
  return _impl_.succs_.size();
}
inline int SPLayer::succs_size() const {
  return _internal_succs_size();
}
inline void SPLayer::clear_succs() {
  _impl_.succs_.Clear();
}
inline int32_t SPLayer::_internal_succs(int index) const {
  return _impl_.succs_.Get(index);
}
inline int32_t SPLayer::succs(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.succs)
  return _internal_succs(index);
}
inline void SPLayer::set_succs(int index, int32_t value) {
  _impl_.succs_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.succs)
}
inline void SPLayer::_internal_add_succs(int32_t value) {
  _impl_.succs_.Add(value);
}
inline void SPLayer::add_succs(int32_t value) {
  _internal_add_succs(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.succs)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer::_internal_succs() const {
  return _impl_.succs_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPLayer::succs() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.succs)
  return _internal_succs();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer::_internal_mutable_succs() {
  return &_impl_.succs_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPLayer::mutable_succs() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.succs)
  return _internal_mutable_succs();
}

// repeated .sapeon.simulator.SPLayer.SPTensor input = 6;
inline int SPLayer::_internal_input_size() const {
  return _impl_.input_.size();
}
inline int SPLayer::input_size() const {
  return _internal_input_size();
}
inline void SPLayer::clear_input() {
  _impl_.input_.Clear();
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_input(int index) {
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.input)
  return _impl_.input_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_SPTensor >*
SPLayer::mutable_input() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.input)
  return &_impl_.input_;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_input(int index) const {
  return _impl_.input_.Get(index);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::input(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.input)
  return _internal_input(index);
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_add_input() {
  return _impl_.input_.Add();
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::add_input() {
  ::sapeon::simulator::SPLayer_SPTensor* _add = _internal_add_input();
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.input)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_SPTensor >&
SPLayer::input() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.input)
  return _impl_.input_;
}

// optional .sapeon.simulator.SPLayer.SPTensor output = 7;
inline bool SPLayer::_internal_has_output() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.output_ != nullptr);
  return value;
}
inline bool SPLayer::has_output() const {
  return _internal_has_output();
}
inline void SPLayer::clear_output() {
  if (_impl_.output_ != nullptr) _impl_.output_->Clear();
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_output() const {
  const ::sapeon::simulator::SPLayer_SPTensor* p = _impl_.output_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPTensor&>(
      ::sapeon::simulator::_SPLayer_SPTensor_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::output() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.output)
  return _internal_output();
}
inline void SPLayer::unsafe_arena_set_allocated_output(
    ::sapeon::simulator::SPLayer_SPTensor* output) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.output_);
  }
  _impl_.output_ = output;
  if (output) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.output)
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::release_output() {
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.output_;
  _impl_.output_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::unsafe_arena_release_output() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.output)
  _impl_._has_bits_[0] &= ~0x00000002u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.output_;
  _impl_.output_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_mutable_output() {
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.output_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(GetArenaForAllocation());
    _impl_.output_ = p;
  }
  return _impl_.output_;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_output() {
  ::sapeon::simulator::SPLayer_SPTensor* _msg = _internal_mutable_output();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.output)
  return _msg;
}
inline void SPLayer::set_allocated_output(::sapeon::simulator::SPLayer_SPTensor* output) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.output_;
  }
  if (output) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(output);
    if (message_arena != submessage_arena) {
      output = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, output, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  _impl_.output_ = output;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.output)
}

// optional .sapeon.simulator.SPLayer.SPTensor filter = 8;
inline bool SPLayer::_internal_has_filter() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.filter_ != nullptr);
  return value;
}
inline bool SPLayer::has_filter() const {
  return _internal_has_filter();
}
inline void SPLayer::clear_filter() {
  if (_impl_.filter_ != nullptr) _impl_.filter_->Clear();
  _impl_._has_bits_[0] &= ~0x00000004u;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_filter() const {
  const ::sapeon::simulator::SPLayer_SPTensor* p = _impl_.filter_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPTensor&>(
      ::sapeon::simulator::_SPLayer_SPTensor_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::filter() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.filter)
  return _internal_filter();
}
inline void SPLayer::unsafe_arena_set_allocated_filter(
    ::sapeon::simulator::SPLayer_SPTensor* filter) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.filter_);
  }
  _impl_.filter_ = filter;
  if (filter) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.filter)
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::release_filter() {
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::unsafe_arena_release_filter() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.filter)
  _impl_._has_bits_[0] &= ~0x00000004u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.filter_;
  _impl_.filter_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_mutable_filter() {
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.filter_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(GetArenaForAllocation());
    _impl_.filter_ = p;
  }
  return _impl_.filter_;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_filter() {
  ::sapeon::simulator::SPLayer_SPTensor* _msg = _internal_mutable_filter();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.filter)
  return _msg;
}
inline void SPLayer::set_allocated_filter(::sapeon::simulator::SPLayer_SPTensor* filter) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.filter_;
  }
  if (filter) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(filter);
    if (message_arena != submessage_arena) {
      filter = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, filter, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  _impl_.filter_ = filter;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.filter)
}

// optional .sapeon.simulator.SPLayer.SPTensor bias = 9;
inline bool SPLayer::_internal_has_bias() const {
  bool value = (_impl_._has_bits_[0] & 0x00000008u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.bias_ != nullptr);
  return value;
}
inline bool SPLayer::has_bias() const {
  return _internal_has_bias();
}
inline void SPLayer::clear_bias() {
  if (_impl_.bias_ != nullptr) _impl_.bias_->Clear();
  _impl_._has_bits_[0] &= ~0x00000008u;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_bias() const {
  const ::sapeon::simulator::SPLayer_SPTensor* p = _impl_.bias_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPTensor&>(
      ::sapeon::simulator::_SPLayer_SPTensor_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::bias() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.bias)
  return _internal_bias();
}
inline void SPLayer::unsafe_arena_set_allocated_bias(
    ::sapeon::simulator::SPLayer_SPTensor* bias) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.bias_);
  }
  _impl_.bias_ = bias;
  if (bias) {
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.bias)
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::release_bias() {
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.bias_;
  _impl_.bias_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::unsafe_arena_release_bias() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.bias)
  _impl_._has_bits_[0] &= ~0x00000008u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.bias_;
  _impl_.bias_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_mutable_bias() {
  _impl_._has_bits_[0] |= 0x00000008u;
  if (_impl_.bias_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(GetArenaForAllocation());
    _impl_.bias_ = p;
  }
  return _impl_.bias_;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_bias() {
  ::sapeon::simulator::SPLayer_SPTensor* _msg = _internal_mutable_bias();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.bias)
  return _msg;
}
inline void SPLayer::set_allocated_bias(::sapeon::simulator::SPLayer_SPTensor* bias) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.bias_;
  }
  if (bias) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(bias);
    if (message_arena != submessage_arena) {
      bias = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bias, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000008u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000008u;
  }
  _impl_.bias_ = bias;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.bias)
}

// optional .sapeon.simulator.SPLayer.SPTensor scale = 10;
inline bool SPLayer::_internal_has_scale() const {
  bool value = (_impl_._has_bits_[0] & 0x00000010u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.scale_ != nullptr);
  return value;
}
inline bool SPLayer::has_scale() const {
  return _internal_has_scale();
}
inline void SPLayer::clear_scale() {
  if (_impl_.scale_ != nullptr) _impl_.scale_->Clear();
  _impl_._has_bits_[0] &= ~0x00000010u;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_scale() const {
  const ::sapeon::simulator::SPLayer_SPTensor* p = _impl_.scale_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPTensor&>(
      ::sapeon::simulator::_SPLayer_SPTensor_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::scale() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.scale)
  return _internal_scale();
}
inline void SPLayer::unsafe_arena_set_allocated_scale(
    ::sapeon::simulator::SPLayer_SPTensor* scale) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.scale_);
  }
  _impl_.scale_ = scale;
  if (scale) {
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.scale)
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::release_scale() {
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::unsafe_arena_release_scale() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.scale)
  _impl_._has_bits_[0] &= ~0x00000010u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.scale_;
  _impl_.scale_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_mutable_scale() {
  _impl_._has_bits_[0] |= 0x00000010u;
  if (_impl_.scale_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(GetArenaForAllocation());
    _impl_.scale_ = p;
  }
  return _impl_.scale_;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_scale() {
  ::sapeon::simulator::SPLayer_SPTensor* _msg = _internal_mutable_scale();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.scale)
  return _msg;
}
inline void SPLayer::set_allocated_scale(::sapeon::simulator::SPLayer_SPTensor* scale) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.scale_;
  }
  if (scale) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(scale);
    if (message_arena != submessage_arena) {
      scale = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, scale, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000010u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000010u;
  }
  _impl_.scale_ = scale;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.scale)
}

// optional .sapeon.simulator.SPLayer.SPTensor mean = 11;
inline bool SPLayer::_internal_has_mean() const {
  bool value = (_impl_._has_bits_[0] & 0x00000020u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.mean_ != nullptr);
  return value;
}
inline bool SPLayer::has_mean() const {
  return _internal_has_mean();
}
inline void SPLayer::clear_mean() {
  if (_impl_.mean_ != nullptr) _impl_.mean_->Clear();
  _impl_._has_bits_[0] &= ~0x00000020u;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_mean() const {
  const ::sapeon::simulator::SPLayer_SPTensor* p = _impl_.mean_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPTensor&>(
      ::sapeon::simulator::_SPLayer_SPTensor_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::mean() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.mean)
  return _internal_mean();
}
inline void SPLayer::unsafe_arena_set_allocated_mean(
    ::sapeon::simulator::SPLayer_SPTensor* mean) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.mean_);
  }
  _impl_.mean_ = mean;
  if (mean) {
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.mean)
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::release_mean() {
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.mean_;
  _impl_.mean_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::unsafe_arena_release_mean() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.mean)
  _impl_._has_bits_[0] &= ~0x00000020u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.mean_;
  _impl_.mean_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_mutable_mean() {
  _impl_._has_bits_[0] |= 0x00000020u;
  if (_impl_.mean_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(GetArenaForAllocation());
    _impl_.mean_ = p;
  }
  return _impl_.mean_;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_mean() {
  ::sapeon::simulator::SPLayer_SPTensor* _msg = _internal_mutable_mean();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.mean)
  return _msg;
}
inline void SPLayer::set_allocated_mean(::sapeon::simulator::SPLayer_SPTensor* mean) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.mean_;
  }
  if (mean) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(mean);
    if (message_arena != submessage_arena) {
      mean = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, mean, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000020u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000020u;
  }
  _impl_.mean_ = mean;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.mean)
}

// optional .sapeon.simulator.SPLayer.SPTensor variance = 12;
inline bool SPLayer::_internal_has_variance() const {
  bool value = (_impl_._has_bits_[0] & 0x00000040u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.variance_ != nullptr);
  return value;
}
inline bool SPLayer::has_variance() const {
  return _internal_has_variance();
}
inline void SPLayer::clear_variance() {
  if (_impl_.variance_ != nullptr) _impl_.variance_->Clear();
  _impl_._has_bits_[0] &= ~0x00000040u;
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::_internal_variance() const {
  const ::sapeon::simulator::SPLayer_SPTensor* p = _impl_.variance_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPTensor&>(
      ::sapeon::simulator::_SPLayer_SPTensor_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPTensor& SPLayer::variance() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.variance)
  return _internal_variance();
}
inline void SPLayer::unsafe_arena_set_allocated_variance(
    ::sapeon::simulator::SPLayer_SPTensor* variance) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.variance_);
  }
  _impl_.variance_ = variance;
  if (variance) {
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.variance)
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::release_variance() {
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.variance_;
  _impl_.variance_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::unsafe_arena_release_variance() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.variance)
  _impl_._has_bits_[0] &= ~0x00000040u;
  ::sapeon::simulator::SPLayer_SPTensor* temp = _impl_.variance_;
  _impl_.variance_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::_internal_mutable_variance() {
  _impl_._has_bits_[0] |= 0x00000040u;
  if (_impl_.variance_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPTensor>(GetArenaForAllocation());
    _impl_.variance_ = p;
  }
  return _impl_.variance_;
}
inline ::sapeon::simulator::SPLayer_SPTensor* SPLayer::mutable_variance() {
  ::sapeon::simulator::SPLayer_SPTensor* _msg = _internal_mutable_variance();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.variance)
  return _msg;
}
inline void SPLayer::set_allocated_variance(::sapeon::simulator::SPLayer_SPTensor* variance) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.variance_;
  }
  if (variance) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(variance);
    if (message_arena != submessage_arena) {
      variance = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, variance, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000040u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000040u;
  }
  _impl_.variance_ = variance;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.variance)
}

// optional float epsilon = 16;
inline bool SPLayer::_internal_has_epsilon() const {
  bool value = (_impl_._has_bits_[0] & 0x00002000u) != 0;
  return value;
}
inline bool SPLayer::has_epsilon() const {
  return _internal_has_epsilon();
}
inline void SPLayer::clear_epsilon() {
  _impl_.epsilon_ = 0;
  _impl_._has_bits_[0] &= ~0x00002000u;
}
inline float SPLayer::_internal_epsilon() const {
  return _impl_.epsilon_;
}
inline float SPLayer::epsilon() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.epsilon)
  return _internal_epsilon();
}
inline void SPLayer::_internal_set_epsilon(float value) {
  _impl_._has_bits_[0] |= 0x00002000u;
  _impl_.epsilon_ = value;
}
inline void SPLayer::set_epsilon(float value) {
  _internal_set_epsilon(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.epsilon)
}

// repeated float input_threshold = 13;
inline int SPLayer::_internal_input_threshold_size() const {
  return _impl_.input_threshold_.size();
}
inline int SPLayer::input_threshold_size() const {
  return _internal_input_threshold_size();
}
inline void SPLayer::clear_input_threshold() {
  _impl_.input_threshold_.Clear();
}
inline float SPLayer::_internal_input_threshold(int index) const {
  return _impl_.input_threshold_.Get(index);
}
inline float SPLayer::input_threshold(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.input_threshold)
  return _internal_input_threshold(index);
}
inline void SPLayer::set_input_threshold(int index, float value) {
  _impl_.input_threshold_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.input_threshold)
}
inline void SPLayer::_internal_add_input_threshold(float value) {
  _impl_.input_threshold_.Add(value);
}
inline void SPLayer::add_input_threshold(float value) {
  _internal_add_input_threshold(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.input_threshold)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer::_internal_input_threshold() const {
  return _impl_.input_threshold_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer::input_threshold() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.input_threshold)
  return _internal_input_threshold();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer::_internal_mutable_input_threshold() {
  return &_impl_.input_threshold_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer::mutable_input_threshold() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.input_threshold)
  return _internal_mutable_input_threshold();
}

// optional float output_threshold = 14;
inline bool SPLayer::_internal_has_output_threshold() const {
  bool value = (_impl_._has_bits_[0] & 0x00001000u) != 0;
  return value;
}
inline bool SPLayer::has_output_threshold() const {
  return _internal_has_output_threshold();
}
inline void SPLayer::clear_output_threshold() {
  _impl_.output_threshold_ = 0;
  _impl_._has_bits_[0] &= ~0x00001000u;
}
inline float SPLayer::_internal_output_threshold() const {
  return _impl_.output_threshold_;
}
inline float SPLayer::output_threshold() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.output_threshold)
  return _internal_output_threshold();
}
inline void SPLayer::_internal_set_output_threshold(float value) {
  _impl_._has_bits_[0] |= 0x00001000u;
  _impl_.output_threshold_ = value;
}
inline void SPLayer::set_output_threshold(float value) {
  _internal_set_output_threshold(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.output_threshold)
}

// repeated float filter_threshold = 15;
inline int SPLayer::_internal_filter_threshold_size() const {
  return _impl_.filter_threshold_.size();
}
inline int SPLayer::filter_threshold_size() const {
  return _internal_filter_threshold_size();
}
inline void SPLayer::clear_filter_threshold() {
  _impl_.filter_threshold_.Clear();
}
inline float SPLayer::_internal_filter_threshold(int index) const {
  return _impl_.filter_threshold_.Get(index);
}
inline float SPLayer::filter_threshold(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.filter_threshold)
  return _internal_filter_threshold(index);
}
inline void SPLayer::set_filter_threshold(int index, float value) {
  _impl_.filter_threshold_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.filter_threshold)
}
inline void SPLayer::_internal_add_filter_threshold(float value) {
  _impl_.filter_threshold_.Add(value);
}
inline void SPLayer::add_filter_threshold(float value) {
  _internal_add_filter_threshold(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.filter_threshold)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer::_internal_filter_threshold() const {
  return _impl_.filter_threshold_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >&
SPLayer::filter_threshold() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.filter_threshold)
  return _internal_filter_threshold();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer::_internal_mutable_filter_threshold() {
  return &_impl_.filter_threshold_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< float >*
SPLayer::mutable_filter_threshold() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.filter_threshold)
  return _internal_mutable_filter_threshold();
}

// optional .sapeon.simulator.SPLayer.SPConvolutionDesc convdesc = 20;
inline bool SPLayer::_internal_has_convdesc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000080u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.convdesc_ != nullptr);
  return value;
}
inline bool SPLayer::has_convdesc() const {
  return _internal_has_convdesc();
}
inline void SPLayer::clear_convdesc() {
  if (_impl_.convdesc_ != nullptr) _impl_.convdesc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000080u;
}
inline const ::sapeon::simulator::SPLayer_SPConvolutionDesc& SPLayer::_internal_convdesc() const {
  const ::sapeon::simulator::SPLayer_SPConvolutionDesc* p = _impl_.convdesc_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPConvolutionDesc&>(
      ::sapeon::simulator::_SPLayer_SPConvolutionDesc_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPConvolutionDesc& SPLayer::convdesc() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.convdesc)
  return _internal_convdesc();
}
inline void SPLayer::unsafe_arena_set_allocated_convdesc(
    ::sapeon::simulator::SPLayer_SPConvolutionDesc* convdesc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.convdesc_);
  }
  _impl_.convdesc_ = convdesc;
  if (convdesc) {
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.convdesc)
}
inline ::sapeon::simulator::SPLayer_SPConvolutionDesc* SPLayer::release_convdesc() {
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sapeon::simulator::SPLayer_SPConvolutionDesc* temp = _impl_.convdesc_;
  _impl_.convdesc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPConvolutionDesc* SPLayer::unsafe_arena_release_convdesc() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.convdesc)
  _impl_._has_bits_[0] &= ~0x00000080u;
  ::sapeon::simulator::SPLayer_SPConvolutionDesc* temp = _impl_.convdesc_;
  _impl_.convdesc_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPConvolutionDesc* SPLayer::_internal_mutable_convdesc() {
  _impl_._has_bits_[0] |= 0x00000080u;
  if (_impl_.convdesc_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPConvolutionDesc>(GetArenaForAllocation());
    _impl_.convdesc_ = p;
  }
  return _impl_.convdesc_;
}
inline ::sapeon::simulator::SPLayer_SPConvolutionDesc* SPLayer::mutable_convdesc() {
  ::sapeon::simulator::SPLayer_SPConvolutionDesc* _msg = _internal_mutable_convdesc();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.convdesc)
  return _msg;
}
inline void SPLayer::set_allocated_convdesc(::sapeon::simulator::SPLayer_SPConvolutionDesc* convdesc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.convdesc_;
  }
  if (convdesc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(convdesc);
    if (message_arena != submessage_arena) {
      convdesc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, convdesc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000080u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000080u;
  }
  _impl_.convdesc_ = convdesc;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.convdesc)
}

// optional .sapeon.simulator.SPLayer.SPSamplingDesc samplingdesc = 21;
inline bool SPLayer::_internal_has_samplingdesc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000100u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.samplingdesc_ != nullptr);
  return value;
}
inline bool SPLayer::has_samplingdesc() const {
  return _internal_has_samplingdesc();
}
inline void SPLayer::clear_samplingdesc() {
  if (_impl_.samplingdesc_ != nullptr) _impl_.samplingdesc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000100u;
}
inline const ::sapeon::simulator::SPLayer_SPSamplingDesc& SPLayer::_internal_samplingdesc() const {
  const ::sapeon::simulator::SPLayer_SPSamplingDesc* p = _impl_.samplingdesc_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPSamplingDesc&>(
      ::sapeon::simulator::_SPLayer_SPSamplingDesc_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPSamplingDesc& SPLayer::samplingdesc() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.samplingdesc)
  return _internal_samplingdesc();
}
inline void SPLayer::unsafe_arena_set_allocated_samplingdesc(
    ::sapeon::simulator::SPLayer_SPSamplingDesc* samplingdesc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.samplingdesc_);
  }
  _impl_.samplingdesc_ = samplingdesc;
  if (samplingdesc) {
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.samplingdesc)
}
inline ::sapeon::simulator::SPLayer_SPSamplingDesc* SPLayer::release_samplingdesc() {
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sapeon::simulator::SPLayer_SPSamplingDesc* temp = _impl_.samplingdesc_;
  _impl_.samplingdesc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPSamplingDesc* SPLayer::unsafe_arena_release_samplingdesc() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.samplingdesc)
  _impl_._has_bits_[0] &= ~0x00000100u;
  ::sapeon::simulator::SPLayer_SPSamplingDesc* temp = _impl_.samplingdesc_;
  _impl_.samplingdesc_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPSamplingDesc* SPLayer::_internal_mutable_samplingdesc() {
  _impl_._has_bits_[0] |= 0x00000100u;
  if (_impl_.samplingdesc_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPSamplingDesc>(GetArenaForAllocation());
    _impl_.samplingdesc_ = p;
  }
  return _impl_.samplingdesc_;
}
inline ::sapeon::simulator::SPLayer_SPSamplingDesc* SPLayer::mutable_samplingdesc() {
  ::sapeon::simulator::SPLayer_SPSamplingDesc* _msg = _internal_mutable_samplingdesc();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.samplingdesc)
  return _msg;
}
inline void SPLayer::set_allocated_samplingdesc(::sapeon::simulator::SPLayer_SPSamplingDesc* samplingdesc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.samplingdesc_;
  }
  if (samplingdesc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(samplingdesc);
    if (message_arena != submessage_arena) {
      samplingdesc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, samplingdesc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000100u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000100u;
  }
  _impl_.samplingdesc_ = samplingdesc;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.samplingdesc)
}

// optional .sapeon.simulator.SPLayer.SPEWAddDesc ewadddesc = 22;
inline bool SPLayer::_internal_has_ewadddesc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000200u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ewadddesc_ != nullptr);
  return value;
}
inline bool SPLayer::has_ewadddesc() const {
  return _internal_has_ewadddesc();
}
inline void SPLayer::clear_ewadddesc() {
  if (_impl_.ewadddesc_ != nullptr) _impl_.ewadddesc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000200u;
}
inline const ::sapeon::simulator::SPLayer_SPEWAddDesc& SPLayer::_internal_ewadddesc() const {
  const ::sapeon::simulator::SPLayer_SPEWAddDesc* p = _impl_.ewadddesc_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPEWAddDesc&>(
      ::sapeon::simulator::_SPLayer_SPEWAddDesc_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPEWAddDesc& SPLayer::ewadddesc() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.ewadddesc)
  return _internal_ewadddesc();
}
inline void SPLayer::unsafe_arena_set_allocated_ewadddesc(
    ::sapeon::simulator::SPLayer_SPEWAddDesc* ewadddesc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ewadddesc_);
  }
  _impl_.ewadddesc_ = ewadddesc;
  if (ewadddesc) {
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.ewadddesc)
}
inline ::sapeon::simulator::SPLayer_SPEWAddDesc* SPLayer::release_ewadddesc() {
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sapeon::simulator::SPLayer_SPEWAddDesc* temp = _impl_.ewadddesc_;
  _impl_.ewadddesc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPEWAddDesc* SPLayer::unsafe_arena_release_ewadddesc() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.ewadddesc)
  _impl_._has_bits_[0] &= ~0x00000200u;
  ::sapeon::simulator::SPLayer_SPEWAddDesc* temp = _impl_.ewadddesc_;
  _impl_.ewadddesc_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPEWAddDesc* SPLayer::_internal_mutable_ewadddesc() {
  _impl_._has_bits_[0] |= 0x00000200u;
  if (_impl_.ewadddesc_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPEWAddDesc>(GetArenaForAllocation());
    _impl_.ewadddesc_ = p;
  }
  return _impl_.ewadddesc_;
}
inline ::sapeon::simulator::SPLayer_SPEWAddDesc* SPLayer::mutable_ewadddesc() {
  ::sapeon::simulator::SPLayer_SPEWAddDesc* _msg = _internal_mutable_ewadddesc();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.ewadddesc)
  return _msg;
}
inline void SPLayer::set_allocated_ewadddesc(::sapeon::simulator::SPLayer_SPEWAddDesc* ewadddesc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ewadddesc_;
  }
  if (ewadddesc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ewadddesc);
    if (message_arena != submessage_arena) {
      ewadddesc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ewadddesc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000200u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000200u;
  }
  _impl_.ewadddesc_ = ewadddesc;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.ewadddesc)
}

// optional .sapeon.simulator.SPLayer.SPEWMulDesc ewmuldesc = 23;
inline bool SPLayer::_internal_has_ewmuldesc() const {
  bool value = (_impl_._has_bits_[0] & 0x00000400u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.ewmuldesc_ != nullptr);
  return value;
}
inline bool SPLayer::has_ewmuldesc() const {
  return _internal_has_ewmuldesc();
}
inline void SPLayer::clear_ewmuldesc() {
  if (_impl_.ewmuldesc_ != nullptr) _impl_.ewmuldesc_->Clear();
  _impl_._has_bits_[0] &= ~0x00000400u;
}
inline const ::sapeon::simulator::SPLayer_SPEWMulDesc& SPLayer::_internal_ewmuldesc() const {
  const ::sapeon::simulator::SPLayer_SPEWMulDesc* p = _impl_.ewmuldesc_;
  return p != nullptr ? *p : reinterpret_cast<const ::sapeon::simulator::SPLayer_SPEWMulDesc&>(
      ::sapeon::simulator::_SPLayer_SPEWMulDesc_default_instance_);
}
inline const ::sapeon::simulator::SPLayer_SPEWMulDesc& SPLayer::ewmuldesc() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.ewmuldesc)
  return _internal_ewmuldesc();
}
inline void SPLayer::unsafe_arena_set_allocated_ewmuldesc(
    ::sapeon::simulator::SPLayer_SPEWMulDesc* ewmuldesc) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.ewmuldesc_);
  }
  _impl_.ewmuldesc_ = ewmuldesc;
  if (ewmuldesc) {
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:sapeon.simulator.SPLayer.ewmuldesc)
}
inline ::sapeon::simulator::SPLayer_SPEWMulDesc* SPLayer::release_ewmuldesc() {
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::sapeon::simulator::SPLayer_SPEWMulDesc* temp = _impl_.ewmuldesc_;
  _impl_.ewmuldesc_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPEWMulDesc* SPLayer::unsafe_arena_release_ewmuldesc() {
  // @@protoc_insertion_point(field_release:sapeon.simulator.SPLayer.ewmuldesc)
  _impl_._has_bits_[0] &= ~0x00000400u;
  ::sapeon::simulator::SPLayer_SPEWMulDesc* temp = _impl_.ewmuldesc_;
  _impl_.ewmuldesc_ = nullptr;
  return temp;
}
inline ::sapeon::simulator::SPLayer_SPEWMulDesc* SPLayer::_internal_mutable_ewmuldesc() {
  _impl_._has_bits_[0] |= 0x00000400u;
  if (_impl_.ewmuldesc_ == nullptr) {
    auto* p = CreateMaybeMessage<::sapeon::simulator::SPLayer_SPEWMulDesc>(GetArenaForAllocation());
    _impl_.ewmuldesc_ = p;
  }
  return _impl_.ewmuldesc_;
}
inline ::sapeon::simulator::SPLayer_SPEWMulDesc* SPLayer::mutable_ewmuldesc() {
  ::sapeon::simulator::SPLayer_SPEWMulDesc* _msg = _internal_mutable_ewmuldesc();
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.ewmuldesc)
  return _msg;
}
inline void SPLayer::set_allocated_ewmuldesc(::sapeon::simulator::SPLayer_SPEWMulDesc* ewmuldesc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete _impl_.ewmuldesc_;
  }
  if (ewmuldesc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ewmuldesc);
    if (message_arena != submessage_arena) {
      ewmuldesc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ewmuldesc, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000400u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000400u;
  }
  _impl_.ewmuldesc_ = ewmuldesc;
  // @@protoc_insertion_point(field_set_allocated:sapeon.simulator.SPLayer.ewmuldesc)
}

// optional .sapeon.simulator.SPLayer.SPActivationMode activation = 30;
inline bool SPLayer::_internal_has_activation() const {
  bool value = (_impl_._has_bits_[0] & 0x00004000u) != 0;
  return value;
}
inline bool SPLayer::has_activation() const {
  return _internal_has_activation();
}
inline void SPLayer::clear_activation() {
  _impl_.activation_ = 0;
  _impl_._has_bits_[0] &= ~0x00004000u;
}
inline ::sapeon::simulator::SPLayer_SPActivationMode SPLayer::_internal_activation() const {
  return static_cast< ::sapeon::simulator::SPLayer_SPActivationMode >(_impl_.activation_);
}
inline ::sapeon::simulator::SPLayer_SPActivationMode SPLayer::activation() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.activation)
  return _internal_activation();
}
inline void SPLayer::_internal_set_activation(::sapeon::simulator::SPLayer_SPActivationMode value) {
  assert(::sapeon::simulator::SPLayer_SPActivationMode_IsValid(value));
  _impl_._has_bits_[0] |= 0x00004000u;
  _impl_.activation_ = value;
}
inline void SPLayer::set_activation(::sapeon::simulator::SPLayer_SPActivationMode value) {
  _internal_set_activation(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPLayer.activation)
}

// repeated .sapeon.simulator.SPLayer.Attribute attributes = 31;
inline int SPLayer::_internal_attributes_size() const {
  return _impl_.attributes_.size();
}
inline int SPLayer::attributes_size() const {
  return _internal_attributes_size();
}
inline void SPLayer::clear_attributes() {
  _impl_.attributes_.Clear();
}
inline ::sapeon::simulator::SPLayer_Attribute* SPLayer::mutable_attributes(int index) {
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPLayer.attributes)
  return _impl_.attributes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_Attribute >*
SPLayer::mutable_attributes() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPLayer.attributes)
  return &_impl_.attributes_;
}
inline const ::sapeon::simulator::SPLayer_Attribute& SPLayer::_internal_attributes(int index) const {
  return _impl_.attributes_.Get(index);
}
inline const ::sapeon::simulator::SPLayer_Attribute& SPLayer::attributes(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPLayer.attributes)
  return _internal_attributes(index);
}
inline ::sapeon::simulator::SPLayer_Attribute* SPLayer::_internal_add_attributes() {
  return _impl_.attributes_.Add();
}
inline ::sapeon::simulator::SPLayer_Attribute* SPLayer::add_attributes() {
  ::sapeon::simulator::SPLayer_Attribute* _add = _internal_add_attributes();
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPLayer.attributes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer_Attribute >&
SPLayer::attributes() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPLayer.attributes)
  return _impl_.attributes_;
}

// -------------------------------------------------------------------

// SPGraph

// repeated .sapeon.simulator.SPLayer layer = 1;
inline int SPGraph::_internal_layer_size() const {
  return _impl_.layer_.size();
}
inline int SPGraph::layer_size() const {
  return _internal_layer_size();
}
inline void SPGraph::clear_layer() {
  _impl_.layer_.Clear();
}
inline ::sapeon::simulator::SPLayer* SPGraph::mutable_layer(int index) {
  // @@protoc_insertion_point(field_mutable:sapeon.simulator.SPGraph.layer)
  return _impl_.layer_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer >*
SPGraph::mutable_layer() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPGraph.layer)
  return &_impl_.layer_;
}
inline const ::sapeon::simulator::SPLayer& SPGraph::_internal_layer(int index) const {
  return _impl_.layer_.Get(index);
}
inline const ::sapeon::simulator::SPLayer& SPGraph::layer(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPGraph.layer)
  return _internal_layer(index);
}
inline ::sapeon::simulator::SPLayer* SPGraph::_internal_add_layer() {
  return _impl_.layer_.Add();
}
inline ::sapeon::simulator::SPLayer* SPGraph::add_layer() {
  ::sapeon::simulator::SPLayer* _add = _internal_add_layer();
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPGraph.layer)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::sapeon::simulator::SPLayer >&
SPGraph::layer() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPGraph.layer)
  return _impl_.layer_;
}

// repeated int32 input_layers = 2;
inline int SPGraph::_internal_input_layers_size() const {
  return _impl_.input_layers_.size();
}
inline int SPGraph::input_layers_size() const {
  return _internal_input_layers_size();
}
inline void SPGraph::clear_input_layers() {
  _impl_.input_layers_.Clear();
}
inline int32_t SPGraph::_internal_input_layers(int index) const {
  return _impl_.input_layers_.Get(index);
}
inline int32_t SPGraph::input_layers(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPGraph.input_layers)
  return _internal_input_layers(index);
}
inline void SPGraph::set_input_layers(int index, int32_t value) {
  _impl_.input_layers_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPGraph.input_layers)
}
inline void SPGraph::_internal_add_input_layers(int32_t value) {
  _impl_.input_layers_.Add(value);
}
inline void SPGraph::add_input_layers(int32_t value) {
  _internal_add_input_layers(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPGraph.input_layers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPGraph::_internal_input_layers() const {
  return _impl_.input_layers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPGraph::input_layers() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPGraph.input_layers)
  return _internal_input_layers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPGraph::_internal_mutable_input_layers() {
  return &_impl_.input_layers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPGraph::mutable_input_layers() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPGraph.input_layers)
  return _internal_mutable_input_layers();
}

// repeated int32 output_layers = 3;
inline int SPGraph::_internal_output_layers_size() const {
  return _impl_.output_layers_.size();
}
inline int SPGraph::output_layers_size() const {
  return _internal_output_layers_size();
}
inline void SPGraph::clear_output_layers() {
  _impl_.output_layers_.Clear();
}
inline int32_t SPGraph::_internal_output_layers(int index) const {
  return _impl_.output_layers_.Get(index);
}
inline int32_t SPGraph::output_layers(int index) const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPGraph.output_layers)
  return _internal_output_layers(index);
}
inline void SPGraph::set_output_layers(int index, int32_t value) {
  _impl_.output_layers_.Set(index, value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPGraph.output_layers)
}
inline void SPGraph::_internal_add_output_layers(int32_t value) {
  _impl_.output_layers_.Add(value);
}
inline void SPGraph::add_output_layers(int32_t value) {
  _internal_add_output_layers(value);
  // @@protoc_insertion_point(field_add:sapeon.simulator.SPGraph.output_layers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPGraph::_internal_output_layers() const {
  return _impl_.output_layers_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >&
SPGraph::output_layers() const {
  // @@protoc_insertion_point(field_list:sapeon.simulator.SPGraph.output_layers)
  return _internal_output_layers();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPGraph::_internal_mutable_output_layers() {
  return &_impl_.output_layers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< int32_t >*
SPGraph::mutable_output_layers() {
  // @@protoc_insertion_point(field_mutable_list:sapeon.simulator.SPGraph.output_layers)
  return _internal_mutable_output_layers();
}

// optional int64 ir_version = 4 [default = 2];
inline bool SPGraph::_internal_has_ir_version() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  return value;
}
inline bool SPGraph::has_ir_version() const {
  return _internal_has_ir_version();
}
inline void SPGraph::clear_ir_version() {
  _impl_.ir_version_ = int64_t{2};
  _impl_._has_bits_[0] &= ~0x00000002u;
}
inline int64_t SPGraph::_internal_ir_version() const {
  return _impl_.ir_version_;
}
inline int64_t SPGraph::ir_version() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPGraph.ir_version)
  return _internal_ir_version();
}
inline void SPGraph::_internal_set_ir_version(int64_t value) {
  _impl_._has_bits_[0] |= 0x00000002u;
  _impl_.ir_version_ = value;
}
inline void SPGraph::set_ir_version(int64_t value) {
  _internal_set_ir_version(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPGraph.ir_version)
}

// optional bool is_optimized = 5 [default = false];
inline bool SPGraph::_internal_has_is_optimized() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  return value;
}
inline bool SPGraph::has_is_optimized() const {
  return _internal_has_is_optimized();
}
inline void SPGraph::clear_is_optimized() {
  _impl_.is_optimized_ = false;
  _impl_._has_bits_[0] &= ~0x00000001u;
}
inline bool SPGraph::_internal_is_optimized() const {
  return _impl_.is_optimized_;
}
inline bool SPGraph::is_optimized() const {
  // @@protoc_insertion_point(field_get:sapeon.simulator.SPGraph.is_optimized)
  return _internal_is_optimized();
}
inline void SPGraph::_internal_set_is_optimized(bool value) {
  _impl_._has_bits_[0] |= 0x00000001u;
  _impl_.is_optimized_ = value;
}
inline void SPGraph::set_is_optimized(bool value) {
  _internal_set_is_optimized(value);
  // @@protoc_insertion_point(field_set:sapeon.simulator.SPGraph.is_optimized)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace simulator
}  // namespace sapeon

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::sapeon::simulator::SPLayer_Attribute_AttributeType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sapeon::simulator::SPLayer_Attribute_AttributeType>() {
  return ::sapeon::simulator::SPLayer_Attribute_AttributeType_descriptor();
}
template <> struct is_proto_enum< ::sapeon::simulator::SPLayer_SPActivationMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sapeon::simulator::SPLayer_SPActivationMode>() {
  return ::sapeon::simulator::SPLayer_SPActivationMode_descriptor();
}
template <> struct is_proto_enum< ::sapeon::simulator::SPLayer_SPSamplingMode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sapeon::simulator::SPLayer_SPSamplingMode>() {
  return ::sapeon::simulator::SPLayer_SPSamplingMode_descriptor();
}
template <> struct is_proto_enum< ::sapeon::simulator::SPLayer_SPDataType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sapeon::simulator::SPLayer_SPDataType>() {
  return ::sapeon::simulator::SPLayer_SPDataType_descriptor();
}
template <> struct is_proto_enum< ::sapeon::simulator::SPLayer_SPTensorFormat> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::sapeon::simulator::SPLayer_SPTensorFormat>() {
  return ::sapeon::simulator::SPLayer_SPTensorFormat_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_spear_2eproto_2ee8e8
